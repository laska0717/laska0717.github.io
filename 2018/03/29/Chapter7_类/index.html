<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Hailu"><title>《C++ Primer 5》Chapter7读书笔记 · Hailu's Blog</title><meta name="description" content="Chapter7的读书笔记，关于类的初级语法与细节知识点

一.定义抽象数据类型1 定义在类内部的函数是隐式的inline函数。
2 this指针本身就是一个常量指针（不允许修改其指向），但是this本身是指向非常量版本的（即可以修改指向的对象的内容），这意味着，this不能绑定到一个常量对象上（人"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Hailu's Blog</a></h3><div class="description"><p>53696C656E636520697320676F6C64</p></div></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">Home</a></li><li><a href="/about">Sobre</a></li><li><a href="/archives">Arquivo</a></li><li><a href="/links">Links</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>《C++ Primer 5》Chapter7读书笔记</a></h3></div><div class="post-content"><p>Chapter7的读书笔记，关于类的初级语法与细节知识点</p>
<a id="more"></a>
<h1 id="一-定义抽象数据类型"><a href="#一-定义抽象数据类型" class="headerlink" title="一.定义抽象数据类型"></a>一.定义抽象数据类型</h1><p>1 定义在类内部的函数是隐式的inline函数。</p>
<p>2 this指针本身就是一个常量指针（不允许修改其指向），但是this本身是指向非常量版本的（即可以修改指向的对象的内容），这意味着，this不能绑定到一个常量对象上（人家对象本身不可改变，访问者也必须遵循对象的意思）。进而，在常量对象上不能调用普通成员函数（对象是常量，要求成员函数也得是常量的，才可以调用，这尊重了对象的意思）。</p>
<p>3 const成员函数，就是将成员函数声明为不会改变对象的（对象说不允许改变，好的，成员函数很诚实的将自己声明为const的，声明自己不会改变对象），这样，常量对象与普通对象（人不在乎）都可以用这个函数了。把const关键字放置在成员函数的参数列表后边（声明&amp;实现），表示this指针是一个指向常量的指针。const成员函数不改变调用他的对象。</p>
<p>4 编译器分两步处理类，首先编译成员声明，然后编译成员函数体。</p>
<p>5 IO类属于不能拷贝的类型，因此只能通过引用传递。</p>
<p>6 类若没有显示定义构造函数，编译器会隐式地定义一个默认构造函数（称为合成的默认构造函数）</p>
<ul>
<li>合成默认构造函数初始化规则<ul>
<li>若有类内初始值，用它初始化成员。</li>
<li>否则，默认初始化。</li>
</ul>
</li>
</ul>
<p>7 编译器只有在发现类不包含<strong>任何</strong>构造函数的情况下，才会替我们生成一个默认构造函数。<strong>一但我们定义了一些其他构造函数，除非我们再定义一个默认构造函数，否则类将不会有默认构造函数</strong>。</p>
<p>8 合成的默认构造函数可能执行错误的操作。</p>
<p>9 有些编译器无能，不能为某系类合成默认的构造函数。</p>
<p>10 C++11中，使用=default()来指定让编译器生成构造函数。既可以与声明在一起，也可以与定义在一起。（于声明在一起表示构造函数是内联的）</p>
<p>11 当某个数据成员被构造函数初始值列表忽略时，它将以与合成默认构造函数相同的方式隐式初始化。</p>
<p>12 如果不定义拷贝，赋值，销毁时的行为，编译器将会为我们合成一个。但是某些类不能依赖与合成的版本。<strong>特别是，当类需要分配对象之外的资源的时候，合成的版本往往会失效</strong></p>
<h1 id="二-访问控制与封装"><a href="#二-访问控制与封装" class="headerlink" title="二.访问控制与封装"></a>二.访问控制与封装</h1><p>1 public之后的成员在整个程序中可被访问；private之后的成员可被成员函数访问，但是不能被使用该类的代码访问。</p>
<p>2 class与struct的唯一区别就是默认访问权限。</p>
<p>3 友元，允许其他类或者函数访问非公有成员。如果一个函数是与类相关的，但是不是类对象的成员函数，而它又要访问类的私有数据成员，就必须在类内对该函数进行友元声明（），在类外对该函数进行普通声明。即友元声明仅仅标识谁是我的朋友，其他的工作不能省略。友元声明只能在类内部出现，但是具体在哪里并不限制。</p>
<h1 id="三-类的其他特性"><a href="#三-类的其他特性" class="headerlink" title="三.类的其他特性"></a>三.类的其他特性</h1><p>1 除了定义数据成员与函数成员，类内还可以定义某种类型（在这个类中）的<strong>别名</strong>，这个称为类型成员，必须先定义后使用。</p>
<p>2 可以在类内部使用inline声明函数为内联的，也可以在类的外部定义的地方加上inline关键字以声明函数为内联的。<strong>建议在类外部定义的地方说明inline</strong></p>
<p>3 有时候，希望能够修改类的某个数据成员（<strong>即使是在一个const成员函数中</strong>），可以通过在变量声明中加入mutable关键字做到这一点。称之为可变数据成员（它永远不是const的）。</p>
<p>4 我们希望类的开始时就有数据成员的初始值（这个称为类内初始化），我们希望这个效果在<strong>类数据成员</strong>上也能实现（即类内某一数据成员的类型也是用户定义的其他类，而非内置类，我们希望也能对这样的数据成员进行类内初始化）。在C++11中，最好方式就是把这个默认值声明成一个类内初始值。</p>
<ul>
<li>类内初始值必须使用=的初始化形式或者花括号括起来的形式。</li>
</ul>
<p>5 <strong>一个const成员函数如果以引用的形式返回*this，那么他返回的类型将是常量引用</strong>（不允许再对所引用对象做出改变）。</p>
<ul>
<li>基于const的重载（使用重载技术解决这个问题）。通过区分成员函数是不是const的，可以进行重载。<ul>
<li>当一个成员调用另一个成员时，this指针隐式的传递。</li>
<li>非常量的成员调用常量成员时，它的this指针隐式的从指向非常量的指针转换成指向常量的指针。</li>
<li>非const函数，返回*this的时候将会返回一个普通引用。而const成员函数将会返回一个常量引用。</li>
<li>例子见《C++ Primer 5》p248。</li>
</ul>
</li>
</ul>
<p>6 可以把类名作为类型的名字使用，也可以把类名跟在class或者struct后面。</p>
<ul>
<li>People obj1;</li>
<li>class People obj2l;</li>
</ul>
<p>7 前向声明（仅仅声明但是不定义），声明之后定义之前是一个<strong>不完全类型</strong>。</p>
<ul>
<li>可以定义指向指向这类型的指针或引用。</li>
<li>可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数。</li>
</ul>
<p>8 一个类的成员类型不能是自己，但是一个类的名字出现以后，它就被认为是声明过的（但尚未定义），此时允许包含指向它自身类型的引用或者指针。</p>
<p>9 友元函数是可以定义在类的内部，这样的函数是<strong>隐式内联</strong>的。</p>
<p>10 定义与声明以及实现需要满足<strong>向前看得到</strong>原则。</p>
<ul>
<li>如果只是使用到了名字，只需看的到曼妙的身影即可（声明）。</li>
<li>如果不仅使用到了名字，还使用到了细节（数据成员或者函数），则需看到精细的构造（定义）。</li>
</ul>
<p>11 想把一组重载函数声明为友元，需要为每一个函数分别声明友元。</p>
<p>12 类与非成员函数的声明不必须在它们的友元声明之前。</p>
<p>13 友元函数可以定义在类内，但是注意。</p>
<ul>
<li>就算定义在类内，也必须在类外提供该函数的声明而使得函数可见。</li>
<li>因为<strong>友元</strong>仅仅只是影响到了权限。</li>
</ul>
<h1 id="四-类的作用域"><a href="#四-类的作用域" class="headerlink" title="四.类的作用域"></a>四.类的作用域</h1><p>1 当成员函数定义在类的外部的时候，返回类型中使用的名字都位于类的作用域之外，这时候，返回类型必须指明他是哪个类的成员（尤其是当返回类型是定义在某个类的内部的时候）。</p>
<p>2 类的定义分为两步：</p>
<ul>
<li>编译成员的声明</li>
<li>直到类全部可见后才编译函数体</li>
</ul>
<p>3 一般来说，内层作用域可以重新定义外层作用域中的名字（覆盖），然而在类中，有一种特殊情况：</p>
<ul>
<li>如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> Money;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Money <span class="title">balance</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> bal; &#125;   <span class="comment">//使用外层作用域中的Money</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">double</span> Money;            <span class="comment">//错误，不能重新定义该名字</span></span><br><span class="line">    Money bal;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="五-造函数再探"><a href="#五-造函数再探" class="headerlink" title="五.造函数再探"></a>五.造函数再探</h1><p>1 如果没有在构造函数的初始值列表中显示地初始化成员，则该成员将在构造函数体之前执行默认初始化，也就是说，如果你没有使用初始值列表来进行初始化，而是在函数体内做赋值操作，其实是先进行了默认初始化，然后做了一个赋值操作。</p>
<p>2 有时候可以忽略初始化与赋值之间的差异，但是以下几种情况必须使用构造函数的初始值列表为这些成员提供初始值（而不是使用赋值操作）：</p>
<ul>
<li>成员是const，因为const不允许改变，而赋值操作是一种改变。</li>
<li>成员是引用，引用一经绑定就不允许改变。</li>
<li>成员是某种类类型，且没有定义默认构造函数</li>
</ul>
<p>3 构造函数初始值列表只能说明用于初始化成员的值，而不限定初始化执行顺序，<strong>成员初始化顺序与在类中的定义顺序一致</strong></p>
<p>4 默认实参构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Sales_data( <span class="built_in">std</span>::<span class="built_in">string</span> s=<span class="string">""</span> )&#123;&#125;</span><br><span class="line">    <span class="comment">//这是一个默认构造函数，其与只接受一个string实参的构造函数的功能相同</span></span><br><span class="line">    <span class="comment">//这里注意，如果构造的时候，没有传入参数，就是相当于默认构造函数</span></span><br><span class="line">    <span class="comment">//如果传入了参数，就是相当于参数构造函数</span></span><br><span class="line">    <span class="comment">//这样的形式称为默认实参</span></span><br><span class="line">    <span class="comment">//如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>5 C++11 委托构造函数，一个委托构造函数使用它所属的类的其他构造函数执行它自己的初始化过程。也就是说，他把他自己的一些（或者全部）职责委托给了其他构造函数。</p>
<p>6 受委托的构造函数的初始值列表和函数体被依次执行。</p>
<ul>
<li>A委托B做构造函数，先执行A的初始值列表，也就是进入B的构造函数，执行B的所有（初始化，函数体等），然后才将控制权交还给A。</li>
</ul>
<p>7 p262</p>
<p>【未完】</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-03-29</span><i class="fa fa-tag"></i><a class="tag" href="/categories/C/" title="C++">C++ </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://yoursite.com/2018/03/29/Chapter7_类/,Hailu's Blog,《C++ Primer 5》Chapter7读书笔记,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/2018/03/29/hello-world/" title="Hello World">Próximo post</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>