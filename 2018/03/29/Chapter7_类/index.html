<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Hailu"><title>《C++ Primer 5》Chapter7读书笔记 · Hailu's Blog</title><meta name="description" content="Chapter7的读书笔记，关于类的初级语法与细节知识点

一.定义抽象数据类型1 定义在类内部的函数是隐式的inline函数。
2 this指针本身就是一个常量指针（不允许修改其指向），但是this本身是指向非常量版本的（即可以修改指向的对象的内容），这意味着，this不能绑定到一个常量对象上（人"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Hailu's Blog</a></h3><div class="description"><p>53696C656E636520697320676F6C64</p></div></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>《C++ Primer 5》Chapter7读书笔记</a></h3></div><div class="post-content"><p>Chapter7的读书笔记，关于类的初级语法与细节知识点</p>
<a id="more"></a>
<h1 id="一-定义抽象数据类型"><a href="#一-定义抽象数据类型" class="headerlink" title="一.定义抽象数据类型"></a>一.定义抽象数据类型</h1><p>1 定义在类内部的函数是隐式的inline函数。</p>
<p>2 this指针本身就是一个常量指针（不允许修改其指向），但是this本身是指向非常量版本的（即可以修改指向的对象的内容），这意味着，this不能绑定到一个常量对象上（人家对象本身不可改变，访问者也必须遵循对象的意思）。进而，在常量对象上不能调用普通成员函数（对象是常量，要求成员函数也得是常量的，才可以调用，这尊重了对象的意思）。</p>
<p>3 const成员函数，就是将成员函数声明为不会改变对象的（对象说不允许改变，好的，成员函数很诚实的将自己声明为const的，声明自己不会改变对象），这样，常量对象与普通对象（人不在乎）都可以用这个函数了。把const关键字放置在成员函数的参数列表后边（声明&amp;实现），表示this指针是一个指向常量的指针。const成员函数不改变调用他的对象。</p>
<p>4 编译器分两步处理类，首先编译成员声明，然后编译成员函数体。</p>
<p>5 IO类属于不能拷贝的类型，因此只能通过引用传递。</p>
<p>6 类若没有显示定义构造函数，编译器会隐式地定义一个默认构造函数（称为合成的默认构造函数）</p>
<ul>
<li>合成默认构造函数初始化规则<ul>
<li>若有类内初始值，用它初始化成员。</li>
<li>否则，默认初始化。</li>
</ul>
</li>
</ul>
<p>7 编译器只有在发现类不包含<strong>任何</strong>构造函数的情况下，才会替我们生成一个默认构造函数。<strong>一但我们定义了一些其他构造函数，除非我们再定义一个默认构造函数，否则类将不会有默认构造函数</strong>。</p>
<p>8 合成的默认构造函数可能执行错误的操作。</p>
<p>9 有些编译器无能，不能为某系类合成默认的构造函数。</p>
<p>10 C++11中，使用=default()来指定让编译器生成构造函数。既可以与声明在一起，也可以与定义在一起。（于声明在一起表示构造函数是内联的）</p>
<p>11 当某个数据成员被构造函数初始值列表忽略时，它将以与合成默认构造函数相同的方式隐式初始化。</p>
<p>12 如果不定义拷贝，赋值，销毁时的行为，编译器将会为我们合成一个。但是某些类不能依赖与合成的版本。<strong>特别是，当类需要分配对象之外的资源的时候，合成的版本往往会失效</strong></p>
<h1 id="二-访问控制与封装"><a href="#二-访问控制与封装" class="headerlink" title="二.访问控制与封装"></a>二.访问控制与封装</h1><p>1 public之后的成员在整个程序中可被访问；private之后的成员可被成员函数访问，但是不能被使用该类的代码访问。</p>
<p>2 class与struct的唯一区别就是默认访问权限。</p>
<p>3 友元，允许其他类或者函数访问非公有成员。如果一个函数是与类相关的，但是不是类对象的成员函数，而它又要访问类的私有数据成员，就必须在类内对该函数进行友元声明（），在类外对该函数进行普通声明。即友元声明仅仅标识谁是我的朋友，其他的工作不能省略。友元声明只能在类内部出现，但是具体在哪里并不限制。</p>
<h1 id="三-类的其他特性"><a href="#三-类的其他特性" class="headerlink" title="三.类的其他特性"></a>三.类的其他特性</h1><p>1 除了定义数据成员与函数成员，类内还可以定义某种类型（在这个类中）的<strong>别名</strong>，这个称为类型成员，必须先定义后使用。</p>
<p>2 可以在类内部使用inline声明函数为内联的，也可以在类的外部定义的地方加上inline关键字以声明函数为内联的。<strong>建议在类外部定义的地方说明inline</strong></p>
<p>3 有时候，希望能够修改类的某个数据成员（<strong>即使是在一个const成员函数中</strong>），可以通过在变量声明中加入mutable关键字做到这一点。称之为可变数据成员（它永远不是const的）。</p>
<p>4 我们希望类的开始时就有数据成员的初始值（这个称为类内初始化），我们希望这个效果在<strong>类数据成员</strong>上也能实现（即类内某一数据成员的类型也是用户定义的其他类，而非内置类，我们希望也能对这样的数据成员进行类内初始化）。在C++11中，最好方式就是把这个默认值声明成一个类内初始值。</p>
<ul>
<li>类内初始值必须使用=的初始化形式或者花括号括起来的形式。</li>
</ul>
<p>5 <strong>一个const成员函数如果以引用的形式返回*this，那么他返回的类型将是常量引用</strong>（不允许再对所引用对象做出改变）。</p>
<ul>
<li>基于const的重载（使用重载技术解决这个问题）。通过区分成员函数是不是const的，可以进行重载。<ul>
<li>当一个成员调用另一个成员时，this指针隐式的传递。</li>
<li>非常量的成员调用常量成员时，它的this指针隐式的从指向非常量的指针转换成指向常量的指针。</li>
<li>非const函数，返回*this的时候将会返回一个普通引用。而const成员函数将会返回一个常量引用。</li>
<li>例子见《C++ Primer 5》p248。</li>
</ul>
</li>
</ul>
<p>6 可以把类名作为类型的名字使用，也可以把类名跟在class或者struct后面。</p>
<ul>
<li>People obj1;</li>
<li>class People obj2l;</li>
</ul>
<p>7 前向声明（仅仅声明但是不定义），声明之后定义之前是一个<strong>不完全类型</strong>。</p>
<ul>
<li>可以定义指向指向这类型的指针或引用。</li>
<li>可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数。</li>
</ul>
<p>8 一个类的成员类型不能是自己，但是一个类的名字出现以后，它就被认为是声明过的（但尚未定义），此时允许包含指向它自身类型的引用或者指针。</p>
<p>9 友元函数是可以定义在类的内部，这样的函数是<strong>隐式内联</strong>的。</p>
<p>10 定义与声明以及实现需要满足<strong>向前看得到</strong>原则。</p>
<ul>
<li>如果只是使用到了名字，只需看的到曼妙的身影即可（声明）。</li>
<li>如果不仅使用到了名字，还使用到了细节（数据成员或者函数），则需看到精细的构造（定义）。</li>
</ul>
<p>11 想把一组重载函数声明为友元，需要为每一个函数分别声明友元。</p>
<p>12 类与非成员函数的声明不必须在它们的友元声明之前。</p>
<p>13 友元函数可以定义在类内，但是注意</p>
<ul>
<li>就算定义在类内，也必须在类外提供该函数的声明而使得函数可见（）</li>
<li>因为<strong>友元</strong>仅仅只是影响到了权限</li>
</ul>
<h1 id="四-类的作用域"><a href="#四-类的作用域" class="headerlink" title="四.类的作用域"></a>四.类的作用域</h1></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-03-29</span><i class="fa fa-tag"></i><a class="tag" href="/categories/C/" title="C++">C++ </a><a class="tag" href="/tags/c/" title="c++">c++ </a><a class="tag" href="/tags/class/" title="class">class </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://yoursite.com/2018/03/29/Chapter7_类/,Hailu's Blog,《C++ Primer 5》Chapter7读书笔记,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/2018/03/29/First/" title="First">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>