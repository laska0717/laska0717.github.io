<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Hailu"><title>《C++ Primer 5》Chapter13读书笔记 · Hailu's Blog</title><meta name="description" content="一.拷贝、赋值与销毁1 定义类时，我们显示或者隐式地指定次类型对象拷贝，移动，赋值，销毁时的行为。一个类通过定义五种特殊的成员函数来控制这些操作，包括：拷贝构造函数，拷贝赋值运算符，移动构造函数，移动赋值运算符，析构函数。

拷贝和移动构造函数：当用同类型的另一个对象初始化本对象时做什么。
拷贝和移"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Hailu's Blog</a></h3><div class="description"><p>53696C656E636520697320676F6C64</p></div></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">Home</a></li><li><a href="/archives">Arquivo</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>《C++ Primer 5》Chapter13读书笔记</a></h3></div><div class="post-content"><h1 id="一-拷贝、赋值与销毁"><a href="#一-拷贝、赋值与销毁" class="headerlink" title="一.拷贝、赋值与销毁"></a>一.拷贝、赋值与销毁</h1><p>1 定义类时，我们显示或者隐式地指定次类型对象<strong>拷贝，移动，赋值，销毁</strong>时的行为。一个类通过定义五种特殊的成员函数来控制这些操作，包括：<strong>拷贝构造函数，拷贝赋值运算符，移动构造函数，移动赋值运算符，析构函数。</strong></p>
<ul>
<li>拷贝和移动构造函数：当用同类型的另一个对象初始化本对象时做什么。</li>
<li>拷贝和移动赋值运算符：将一个对象赋予同类型的另一个对象时做什么。</li>
<li>析构函数：此类对象销毁时做什么。</li>
</ul>
<p>2 一个类如果没有定义这些拷贝控制成员，编译器也会自动为它定义缺失的操作。但是，依赖默认操作将会导致灾难。</p>
<p>3 拷贝构造函数：一个构造函式，第一个参数是自身类类型的引用（此参数几乎总是一个const的引用），任何额外参数都有默认值，则此构造函数是拷贝构造函数。<strong>因为拷贝构造函数在几种情况下都会被隐式地使用。因此，拷贝构造函数通常不应该是explicit（抑制隐式类型转换）。即，允许隐式类型转换。</strong></p>
<p>4 如果我们没有定义拷贝构造函数，编译器会为我们定义一个。与合成默认构造函数不同，<strong>即使定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。</strong></p>
<p>5 一般情况下，合成的拷贝构造函数，会将其参数的成员逐个拷贝到正在创建的对象中，编译器从给定对象中依次将每个非static成员（因为static成员是属于类的）拷贝到正在创建的对象中。一个类的成员拷贝是遵循以下原则：如果成员是类类型，会使用其拷贝构造函数来拷贝（递归的）；内置类型成员则直接拷贝。虽然不能直接拷贝一个数组，但是合成拷贝构造函数会逐元素地拷贝一个数组类型的成员。如果数组元素是类类型，则使用元素的拷贝构造函数来进行拷贝。</p>
<p>6 直接初始化与拷贝初始化之间的差异：直接初始化是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数；拷贝初始化，是要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要，还要进行类型转换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">dots</span><span class="params">(<span class="number">10</span>, <span class="string">'.'</span>)</span></span>; <span class="comment">// direct initialization</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(dots)</span></span>; <span class="comment">// direct initialization</span></span><br><span class="line"><span class="built_in">string</span> s2 = dots; <span class="comment">// copy initialization</span></span><br><span class="line"><span class="built_in">string</span> null_book = <span class="string">"9-999-99999-9"</span>; <span class="comment">// copy initialization</span></span><br><span class="line"><span class="built_in">string</span> nines = <span class="built_in">string</span>(<span class="number">100</span>, <span class="string">'9'</span>); <span class="comment">// copy initialization</span></span><br></pre></td></tr></table></figure>
<p>7 拷贝初始化通常使用拷贝构造函数来完成，但是，如果一个类有一个移动构造函数，则拷贝初始化有时会使用移动构造函数而非拷贝构造函数来完成。</p>
<p>8 <strong>会发生拷贝初始化的情景</strong></p>
<ul>
<li>用=定义变量的时候</li>
<li>将一个对象作为实参传递给一个非引用类型的形参</li>
<li>从一个返回类型为非引用类型的函数返回一个对象</li>
<li>用花括号列表初始化一个数组中的元素或一个聚合类中的成员</li>
</ul>
<p>9 某些类类型还会对它们所分配的对象使用拷贝初始化。例如：</p>
<ul>
<li>初始化标准容器或者调用其insert或push成员时，容器会对元素进行拷贝初始化。</li>
<li>与之相对，用emplace成员创建的元素都进行直接初始化。</li>
</ul>
<p>10 函数调用过程中，具有非引用类型的参数要进行拷贝初始化。类似，当一个函数具有非引用的返回类型时，返回值会被用来初始化调用方的结果。</p>
<p>11 拷贝构造函数的参数必须是引用类型，如果其参数不是引用类型，则调用永远不会成功————为了调用拷贝构造函数，则必须拷贝实参，但是为了拷贝实参，又需要调用拷贝构造函数，如此无限循环。</p>
<p>12 拷贝初始化的限制:因为vector的接受单一大小参数的构造函数是explicit的，所以下面代码中，第一行对，第二行错（是explicit的）。出于同样原因，当传递一个实参或从函数返回一个值时，我们不能隐式使用一个explicit构造函数，所以第四行错，第五行对。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1(<span class="number">10</span>); <span class="comment">// ok: direct initialization</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2 = <span class="number">10</span>; <span class="comment">// error: constructor that takes a size is explicit</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;)</span></span>; <span class="comment">// f's parameter is copy initialized</span></span><br><span class="line">f(<span class="number">10</span>); <span class="comment">// error: can't use an explicit constructor to copy an argument</span></span><br><span class="line">f(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>)); <span class="comment">// ok: directly construct a temporary vector from an int</span></span><br></pre></td></tr></table></figure>
<p>13 <font color="#0099ff" size="3">编译器可以绕过拷贝构造函数：意思是说，明面上编译器可能要用到拷贝构造函数，但是实际上编译器可能绕过了拷贝构造函数的意思。例如：</font></p>
<ul>
<li>在拷贝初始化过程中，编译器可以跳过拷贝构造函数，直接创建对象。即，编译器允许将下面的代码</li>
<li>string null_book = “999”;　　//1</li>
<li>改写为</li>
<li>string null_book(“999”);　　//2</li>
<li><p>由于string的构造函数不是一个explicit的，所以说string类型允许从const char* 到string的隐式转换。在行1中，首先将”999”隐式转化为一个string的临时对象，然后应该调用string的拷贝构造函数对null_book初始化。即：</p>
<ul>
<li>string temp_str(“999”);</li>
<li>string null_book = temp_str;    //或者 string null_book(temp_str);</li>
</ul>
</li>
</ul>
<p>在这里编译器会进行优化，跳过拷贝构造函数直接创建对象。使临时变量成为所要创建的对象。类似的下面代码也会跳过拷贝构造函数：</p>
<ul>
<li>string str = string();</li>
</ul>
<p>但是在这种情况下，拷贝构造函数必须是public的，否则编译会不通过。可能是因为如果拷贝构造函数是private的话，编译器会理解为不能够使用拷贝构造函数，进而不会进行这种优化。可以参见这个博客：<a href="http://www.cnblogs.com/uangyy/p/5516935.html" target="_blank" rel="noopener">http://www.cnblogs.com/uangyy/p/5516935.html</a></p>
<p>14 拷贝赋值运算符：这是类控制对象如何赋值。如果类未定义自己的拷贝赋值运算符，编译器会为它合成一个。这里用到了运算符重载的技术。</p>
<p>15 如果一个运算符是成员函数，其左侧运算对象就绑定到隐式的this参数。对于一个二元运算符，例如赋值运算符，其右侧运算对象作为显示参数传递。</p>
<p>16 拷贝赋值运算符接受一个与其所在类相同类型的参数。（为了与内置类型的赋值保持一致，赋值运算符通常返回一个指向其左侧运算对象的引用）</p>
<p>17 如果一个类没有定义自己的拷贝赋值运算符，编译器会为它生成一个合成拷贝赋值运算符。他会将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员。对于数组类型成员，逐个赋值数组元素。合成拷贝赋值运算符返回一个指向其左侧运算对象的引用。</p>
<p>18 析构函数：构造函数初始化对象非static数据成员以及其他工作，而析构函数释放对象使用的资源，并销毁对象的非static数据成员。一个类只会有唯一一个析构函数。析构函数也会有一个函数体和一个析构部分，在析构函数中，首先执行函数体，然后销毁成员，成员按照初始化顺序的逆序销毁。析构部分是隐式的，不存在类似构造函数中初始化列表的东西来控制成员如何销毁。成员销毁时发生什么完全依赖于成员的类型。销毁类类型的成员需要执行成员自己的析构函数，内置类型无析构函数，直接就销毁了。</p>
<p>19 <strong>隐式销毁一个内置指针类型的成员不会delete它所指向的对象，与普通指针不同的是，智能指针成员是类类型，在析构阶段会被自动销毁</strong></p>
<p>20 什么时候会调用析构函数：无论何时一个对象被销毁，就会自动调用其析构函数。</p>
<ul>
<li>变量在离开其作用域时被销毁</li>
<li>当一个对象被销毁时，其成员被销毁</li>
<li>容器被销毁时，元素被销毁</li>
<li>对于<strong>动态分配的对象，当对指向它的指针应用delete运算符时被销毁</strong></li>
<li>对于临时对象，当创建它的完整表达式结束时被销毁</li>
</ul>
<p>21 当指向一个对象的引用或指针离开作用域时，析构函数不会执行。</p>
<p>22 合成析构函数：当一个类没有定义析构函数时，编译器会为它定义一个合成析构函数。<strong>对于某些类，合成析构函数被用来阻止改类型的对象被销毁</strong>。<strong>析构函数体自身并不直接销毁成员，成员是在析构函数体之后隐含的析构阶段中被销毁的。整个对象销毁阶段，析构函数体是作为成员销毁步骤之外的另一部分而进行的。</strong></p>
<p>23 有三个基本操作可以控制类的拷贝操作：拷贝构造函数，拷贝赋值运算符，析构函数；新标准C++11下，一个类还可以定义一个移动构造函数与一个移动赋值运算符。</p>
<p>24 <strong>需要析构函数的类也需要拷贝与赋值操作：</strong>如果一个类需要程序员显示的定义析构函数，表明其合成的析构函数无法满足需求，暗示类内可能有指针数据成员（合成的析构函数不会delete一个指针数据成员）。进而可知，合成的拷贝与赋值操也可能会要处理指针，这就要求程序员去定义自己的拷贝与赋值操作，而不是使用编译器合成的。</p>
<p>25 <strong>需要拷贝操作的类也需要赋值操作，反之亦然：</strong>这个好理解，可能是该类型还有一个特殊的字段，比如唯一的ID号等，在做拷贝或者赋值操作的时候需要特别处理一下。</p>
<p>26 C++11中，通过将拷贝控制成员定义为=default来显示地要求编译器生成合成的版本。类内使用=default修饰成员的声明时，合成的函数将隐式地声明为内联的。如果不希望合成的成员是内联的，就应该只对成员的类外定义使用=default。</p>
<p>27 C++11中，对于某些类来说，拷贝构造函数与拷贝赋值运算符没有意义，应该删除。此时，定义类应该采用某种机制阻止拷贝或者赋值。例如iostream类阻止了拷贝，以避免多个对象写入或读取相同的IO缓冲。我们定义删除的函数来显示的说明类成员函数时删除的，不可用的。通过将拷贝构造函数与拷贝赋值运算符定义为删除的函数来<strong>阻止拷贝</strong>。删除函数：是说虽然我们声明了他们，但是我们声明的是其不可用，从而达到不使用他们的目的。在参数列表后面加上=delete来指出希望将它定义为删除的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NoCopy</span> &#123;</span></span><br><span class="line">    NoCopy() = <span class="keyword">default</span>; <span class="comment">// use the synthesized default constructor</span></span><br><span class="line">    NoCopy(<span class="keyword">const</span> NoCopy&amp;) = <span class="keyword">delete</span>; <span class="comment">// no copy</span></span><br><span class="line">    NoCopy &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> NoCopy&amp;) = <span class="keyword">delete</span>; <span class="comment">// no assignment</span></span><br><span class="line">    ~NoCopy() = <span class="keyword">default</span>; <span class="comment">// use the synthesized destructor</span></span><br><span class="line">    <span class="comment">// other members</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>28 =delete必须出现在函数第一次声明的时候，而default则可以不这样。可以对任何函数指定=delete，而=default只能使用于个别拷贝控制操作。</p>
<p>29 <strong>析构函数不能是删除的：</strong>不能定义析构函数是删除的，否则，将无法销毁此类型对象。<strong>对于一个删除了析构函数的类型，编译器将不允许定义该类型的变量或创建该类的临时对象。如果一个类有某个成员的类型删除了析构函数，我们也不能定义该类的变量或临时对象。</strong></p>
<p>30 <strong>对于删除了析构函数的类型，虽然我不能定义这种类型的变量或者成员，但可以动态分配这种类型的对象，但是不能释放这些对象</strong>（真折腾）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NoDtor</span> &#123;</span></span><br><span class="line">    NoDtor() = <span class="keyword">default</span>; <span class="comment">// use the synthesized default constructor</span></span><br><span class="line">    ~NoDtor() = <span class="keyword">delete</span>; <span class="comment">// we can't destroy objects of type NoDtor</span></span><br><span class="line">&#125;;</span><br><span class="line">NoDtor nd; <span class="comment">// error: NoDtor destructor is deleted</span></span><br><span class="line">NoDtor *p = <span class="keyword">new</span> NoDtor(); <span class="comment">// ok: but we can't delete p</span></span><br><span class="line"><span class="keyword">delete</span> p; <span class="comment">// error: NoDtor destructor is deleted</span></span><br></pre></td></tr></table></figure>
<p>31 合成的拷贝控制成员可能是删除的：如前，如果我们没有定义拷贝控制成员，编译器会为我们定义合成的版本。类似，如果一个类未定义构造函数，编译器会为其合成一个默认的构造函数。但是，<strong>对于某些类来说，编译器将这些合成的成员定义为删除的函数：</strong></p>
<ul>
<li>若类的某个成员的析构函数是删除的或不可访问的（例如private的），则类的合成析构函数被定义为删除的。</li>
<li>若类的某个成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的。<strong>如果类的某个成员的析构函数是删除的或不可访问的，则类合成的拷贝构造函数也被定义为删除的。</strong></li>
<li>若类的某个成员的拷贝赋值运算符是删除的或者不可访问的，或者是类有一个const成员或引用成员，则类的合成拷贝赋值运算符被定义为删除的。（补充：在C++中，const成员变量也不能在类定义处初始化，只能通过构造函数初始化列表进行，并且必须有构造函数。const数据成员 只在某个对象生存期内是常量，而对于整个类而言却是可变的。因为类可以创建多个对象，不同的对象其const数据成员的值可以不同。所以不能在类的声明中初始化const数据成员，因为类的对象没被创建时，编译器不知道const数据成员的值是什么。const数据成员的初始化只能在类的构造函数的初始化列表中进行。要想建立在整个类中都恒定的常量，应该用类中的枚举常量来实现，或者static cosnt）</li>
<li>若类的某个成员的析构函数是删除的或者不可访问的，<strong>或者是类有一个引用成员，没有类内初始化器</strong>，或者是<strong>类有一个const成员，它没有类内初始化器其类型没有显示定义默认构造函数</strong>，则该类的默认构造函数被定义为删除的。</li>
<li>综上，如果一个类有数据成员不能默认构造，拷贝，赋值，销毁，则该类对应的成员函数被定义为删除的。</li>
</ul>
<p>32 一个成员有删除的或不可访问的析构函数会导致合成的默认和拷贝构造函数被定义为删除的（这个好理解，否则就会出现无法销毁的对象，编译器会尽量避免这种状况）。</p>
<p>33 对于具有引用成员或无法默认构造的const成员的类，编译器不会为其合成默认构造函数：<strong>如果一个类有const成员，则它不能使用合成的拷贝赋值运算符。毕竟，此运算符试图赋值所有成员，而将一个新值赋予一个const对象是不可能的；虽然可以将新值赋予一个引用成员，但这样做改变的是引用所指对象的值，而不是引用本身。这与预期不相符，所以对于有引用成员的类，合成拷贝赋值运算符被定义为删除的。</strong></p>
<p>34 private拷贝控制，在新标准C++11发布之前，类是通过将其拷贝构造函数于拷贝赋值运算符声明为private的来阻止拷贝：由于析构函数是public的，用户可以定义对象，但是不能拷贝这个对象，然而，友元和成员函数依旧可以拷贝对象。为了阻止友元和成员函数中进行的拷贝工作，我们要<strong>将这些操作声明为private的且不定义它们</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrivateCopy</span> &#123;</span></span><br><span class="line">    <span class="comment">// no access specifier; following members are private by default; see § 7.2 (p.268)</span></span><br><span class="line">    <span class="comment">// copy control is private and so is inaccessible to ordinary user code</span></span><br><span class="line">    PrivateCopy(<span class="keyword">const</span> PrivateCopy&amp;);</span><br><span class="line">    PrivateCopy &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> PrivateCopy&amp;);</span><br><span class="line">    <span class="comment">// other members</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    PrivateCopy() = <span class="keyword">default</span>; <span class="comment">// use the synthesized default constructor</span></span><br><span class="line">    ~PrivateCopy(); <span class="comment">// users can define objects of this type but not copy them</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>35 声明函数而不定义它们是合法的操作（除了一个例外），试图访问未定义的操作将会导致一个链接时错误。<strong>试图拷贝对象的用户代码将在编译阶段被标记未错误的；而成员函数或友元函数中的拷贝操作将会导致链接时错误。</strong></p>
<p>36 建议使用C++11新标准的写法=delete</p>
<h1 id="二-拷贝控制和资源管理"><a href="#二-拷贝控制和资源管理" class="headerlink" title="二.拷贝控制和资源管理"></a>二.拷贝控制和资源管理</h1><p>1 两种拷贝语义，一般来说，有两种选择：可以定义拷贝操作，使类的行为看起来像一个值或者像一个指针。</p>
<ul>
<li>行为像值的类：它应该有自己的状态，副本与原对象是完全独立的。</li>
<li>行为像指针的类：共享状态，拷贝一个对象时，副本与原对象使用相同的底层数据，改变副本也会改变原对象，反之亦然。</li>
</ul>
<p>2 IO类型和unique_ptr不允许拷贝与赋值，因此它们的行为既不像值也不像指针。</p>
<p>3 行为像值得类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HasPtr(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s = <span class="built_in">std</span>::<span class="built_in">string</span>()):ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(s)), i(<span class="number">0</span>) &#123; &#125;</span><br><span class="line">    <span class="comment">// each HasPtr has its own copy of the string to which ps points</span></span><br><span class="line">    HasPtr(<span class="keyword">const</span> HasPtr &amp;p):ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(*p.ps)), i(p.i) &#123; &#125;</span><br><span class="line">    <span class="comment">//注意这里的构造与拷贝构造操作，都是新建了一个string对象然后让指针指过去。</span></span><br><span class="line">    HasPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr &amp;);</span><br><span class="line">    ~HasPtr() &#123; <span class="keyword">delete</span> ps; &#125;</span><br><span class="line">    <span class="comment">//注意析构函数的函数体中手动的delete指针（因为用了new）</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *ps;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>4 类值拷贝赋值运算符：赋值运算符通常组合了析构函数和构造函数的操作：</p>
<ul>
<li>类似析构函数，赋值操作会销毁左侧运算对象的资源；</li>
<li>类似拷贝构造函数。赋值操作会从右侧运算对象拷贝数据；</li>
<li>这些操作必须是以<strong>正确的顺序</strong>执行的，<strong>即使将一个对象赋予自身，也要保证正确。</strong></li>
<li>如果可能，还希望赋值运算符是异常安全的，当异常发生的时候，能将左侧对象置于一个有意义的状态。</li>
</ul>
<p>5 通过先拷贝右侧运算对象，处理自赋值情况，并能保证异常发生时代码也是安全的；拷贝完成后，释放左侧运算对象资源，并更新指针指向。如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr &amp;rhs)&#123;</span><br><span class="line">    <span class="keyword">auto</span> newp = <span class="keyword">new</span> <span class="built_in">string</span>(*rhs.ps); <span class="comment">// copy the underlying string先将右侧底层string拷贝至临时string，并让临时newp指向临时string</span></span><br><span class="line">    <span class="keyword">delete</span> ps; <span class="comment">// free the old memory删除释放左侧指针</span></span><br><span class="line">    ps = newp; <span class="comment">// copy data from rhs into this object将右侧运算对象拷贝至左侧运算对象</span></span><br><span class="line">    i = rhs.i;<span class="comment">//其余值操作</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// return this object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6 编写赋值运算符时，一个好的方式是先将右侧运算对象拷贝的局部临时对象中。当拷贝完成以后，销毁左侧运算对象的现有成员就是安全的了。左侧对象销毁后，就将数据从临时对象拷贝到左侧运算对象中。<strong>Tips：销毁左侧运算对象资源之前拷贝右侧运算对象。</strong></p>
<p>7 行为像指针的类：来拷贝指针成员本身而不是它所指，任然需要自己的析构函数来释放接受string参数的构造函数分配的内存。但是析构函数一般不能单方面释放关联的指针，只有最后一个指向对象的指针在进行销毁的时候才可以释放。<strong>最好使用shared——ptr</strong>来管理类中资源。有时候，我们也希望自己直接管理资源，这时候，使用<strong>引用计数</strong>就很有用了。</p>
<p>8 引用计数的工作方式：</p>
<ul>
<li>每个构造函数除了初始化对象以外，还需要创建一个引用计数，用来记录<strong>有多少对象与正在创建的对象共享状态。</strong>创建对象时，只有一个对象共享状态，因此将计数器初始化为1。</li>
<li>拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员。包括计数器，拷贝构造函数递增共享的计数器，指出给定对象的状态又被新的用户共享。</li>
<li>析构函数递减计数器，如果计数器变为0，则析构函数释放状态。</li>
<li>拷贝赋值运算符，<strong>递增右侧运算对象的计数器，递减左侧运算对象的计数器。若左侧计数器变为0，则销毁状态。</strong></li>
</ul>
<p>9 难题：哪里存放引用计数？显而易见的是计数器不能作为对象的成员，否则将无法实现计数器的全局更新。<strong>解决之道之一是将计数器保存在动态内存中，当创建对象时分配新的计数器，拷贝或者赋值时则拷贝指向计数器的指针，这样副本与原对像都会指向相同的计数器。</strong></p>
<p>10 定义一个使用引用计数的类：通过使用引用计数，编写类指针的HasPtr版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// constructor allocates a new string and a new counter, which it sets to 1</span></span><br><span class="line">    <span class="comment">//新的string，新的计数器，且将计数器置为1</span></span><br><span class="line">    HasPtr(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s = <span class="built_in">std</span>::<span class="built_in">string</span>()):ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(s)), i(<span class="number">0</span>), use(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="keyword">size_t</span>(<span class="number">1</span>))&#123; &#125;</span><br><span class="line">    <span class="comment">// copy constructor copies all three data members and increments the counter</span></span><br><span class="line">    <span class="comment">//拷贝指针而非指针所指，拷贝计数指针（指向参数所指的动态内存），更改计数</span></span><br><span class="line">    HasPtr(<span class="keyword">const</span> HasPtr &amp;p):ps(p.ps), i(p.i), use(p.use) &#123; ++*use; &#125;</span><br><span class="line">    HasPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr&amp;);</span><br><span class="line">    ~HasPtr();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *ps;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> *use; <span class="comment">// member to keep track of how many objects share*ps</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HasPtr::~HasPtr()&#123;</span><br><span class="line">    <span class="keyword">if</span> (--*use == <span class="number">0</span>) &#123; <span class="comment">// if the reference count goes to 0</span></span><br><span class="line">        <span class="keyword">delete</span> ps; <span class="comment">// delete the string</span></span><br><span class="line">        <span class="keyword">delete</span> use; <span class="comment">// and the counter</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr &amp;rhs)&#123;</span><br><span class="line">    ++*rhs.use; <span class="comment">// increment the use count of the right-hand operand</span></span><br><span class="line">    <span class="keyword">if</span> (--*use == <span class="number">0</span>) &#123; <span class="comment">// then decrement this object's counter</span></span><br><span class="line">        <span class="keyword">delete</span> ps; <span class="comment">// if no other users</span></span><br><span class="line">        <span class="keyword">delete</span> use; <span class="comment">// free this object's allocated members</span></span><br><span class="line">    &#125;</span><br><span class="line">    ps = rhs.ps; <span class="comment">// copy data from rhs into this object</span></span><br><span class="line">    i = rhs.i;</span><br><span class="line">    use = rhs.use;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// return this object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>11 上述中的赋值运算符必须处理自赋值的情况，我们通过先递增rhs的计数然后再递减左侧运算对象中的计数来实现这一点。</p>
<p>12 <font color="#ff0000" size="4">注意：为什么不用静态成员做引用计数呢？请注意这样的想法有一个严重的问题。静态成员是归类所有的而不是归对象所有的。当我们想要创建一个新的对象的时候，默认取到的引用计数是类中已经存有的引用计数，而不是初始时候的0（或者1）。例如：假设我们先创建了一个对象a，并且创建了一些(类指针的)指向该对象的类类型对象，并且它们的引用计数都正确了，到这里都很正常。但是，此时如果我们想要创建另一个新得该类型对象b的时候，将会发现，此时b取到的引用计数是类已经有的的引用计数而不是初始的0（或者1），这是荒唐的。也就是说该引用计数归为了类所有，而不是某一个对象。</font></p>
<h1 id="三-交换操作"><a href="#三-交换操作" class="headerlink" title="三.交换操作"></a>三.交换操作</h1><p>1 除了定义拷贝控制以外，管理资源的类通常还要定义一个swap()函数，该函数对于那些需要重排元素顺序的类具有重要的意义。</p>
<p>2 如果类定义了自己的swap，那么算法将使用类自定义版本。否则，算法将使用标准库定义的swap。</p>
<p>3 对于行为像指针的类</p>
<ul>
<li>初始时我们定义这样的swap函数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HasPtr temp = v1; <span class="comment">// make a temporary copy of the value of v1</span></span><br><span class="line">v1 = v2; <span class="comment">// assign the value of v2 to v1</span></span><br><span class="line">v2 = temp; <span class="comment">// assign the saved value of v1 to v2</span></span><br><span class="line">但是这样的代码将会不必要的分配临时内存给<span class="built_in">string</span></span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">其实可以这样</span><br><span class="line"><span class="built_in">string</span> *temp = v1.ps; <span class="comment">// make a temporary copy of the pointer in v1.ps</span></span><br><span class="line">v1.ps = v2.ps; <span class="comment">// assign the pointer in v2.ps to v1.ps</span></span><br><span class="line">v2.ps = temp; <span class="comment">// assign the saved pointer in v1.ps to v2.ps</span></span><br><span class="line">用交换指针的方式，减少了空间开销。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>4 编写自己版本的swap函数来重载swap的默认行为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(HasPtr&amp;, HasPtr&amp;)</span></span>;</span><br><span class="line">    <span class="comment">// other members as in § 13.2.1 (p. 511)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(HasPtr &amp;lhs, HasPtr &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">    swap(lhs.ps, rhs.ps); <span class="comment">//交换指针而不是string数据</span></span><br><span class="line">    swap(lhs.i, rhs.i); <span class="comment">// swap the int members</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5 注意函数调用的是自己定义的swap还是std::swap</p>
<ul>
<li>上例中，对于内置类型的成员（本例中是指针与int）调用的swap是标准库的std::swap</li>
<li><p>但是考虑如果一个类的成员有它自己的swap函数，调用std::swap就会是不合适的。考虑这样一个Foo类，他有类型为HasPtr的成员h，如果我们已经为HasPtr定义了自己的swap（像上例中一样）。如果我们没有为Foo定义swap，那么将会使用默认的std::swap来对Foo类对象进行交换操作（这种默认操作会对所有的成员也使用默认std::swap操作），这将导致对HasPtr管理的string的不必要的拷贝。</p>
</li>
<li><p>为Foo定义自己的swap</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Foo &amp;lhs, Foo &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 错误:这里显示使用了标准的std::swap而不是HasPtr版本的</span></span><br><span class="line">    <span class="built_in">std</span>::swap(lhs.h, rhs.h);</span><br><span class="line">    <span class="comment">// swap other members of type Foo</span></span><br><span class="line">&#125;</span><br><span class="line">-------------------------------------------------------</span><br><span class="line"><span class="comment">//应该定义为如下的样子</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Foo &amp;lhs, Foo &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">    swap(lhs.h, rhs.h); <span class="comment">// uses the HasPtr version of swap</span></span><br><span class="line">    <span class="comment">// swap other members of type Foo</span></span><br><span class="line">&#125;</span><br><span class="line">我们在这里声明了<span class="built_in">std</span>::awap的命名空间，之后调用了swap函数（HasPtr定义的）。如果存在特定类型的swap版本，其匹配程度将会优于<span class="built_in">std</span>版本的。所以，上述代码是先寻找特定版本的swap，如果没有就会使用<span class="built_in">std</span>版本的（前提是作用域中有<span class="keyword">using</span>的声明，感觉这样的声明是为了保证代码的健壮性。即总会有一个<span class="built_in">std</span>::swap为用户兜底）。出于之后介绍的知识点（命名空间），这里<span class="keyword">using</span>声明并没有隐藏特定版本的swap声明。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>6 在赋值运算符中使用swap来达到目的（一种贱贱的做法）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(HasPtr rhs)</span><br><span class="line">&#123;</span><br><span class="line">    swap(*<span class="keyword">this</span>, rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7 rhs是右侧对象的副本（注意这里是传值而不是传引用，所以函数体内的变化不会影响函数体外），不过就是多了一次拷贝构造的工作；swap交换正常；这个技术有趣的地方在于他自动处理了自赋值的情况（天然安全）；唯一会发生异常的地方在拷贝构造过程中的new表达式(内存空间不足呀啥的)，但是也会在改变左侧对象之前发生，所以是异常安全的。</p>
<h1 id="四-拷贝控制示例"><a href="#四-拷贝控制示例" class="headerlink" title="四.拷贝控制示例"></a>四.拷贝控制示例</h1><p>1 分配资源的类需要拷贝控制，但是一些类也需要拷贝控制成员的帮助来进行簿记工作或其他操作。</p>
<h1 id="五-动态内存管理类"><a href="#五-动态内存管理类" class="headerlink" title="五.动态内存管理类"></a>五.动态内存管理类</h1><p>1 某些类需要运行时分配可变大小的内存空间，通常可以使用标准库容器来保存数据，但是某些类需要自己进行内存分配。这些类一般需要定义自己的拷贝控制成员来管理所分配的内存。以下内容时模拟实现一个简化的vector，不使用模板，仅针对string。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrVec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StrVec(): <span class="comment">// the allocator member is default initialized</span></span><br><span class="line">    elements(<span class="literal">nullptr</span>), first_free(<span class="literal">nullptr</span>), cap(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    StrVec(<span class="keyword">const</span> StrVec&amp;); <span class="comment">// copy constructor</span></span><br><span class="line">    StrVec &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> StrVec&amp;); <span class="comment">// copy assignment</span></span><br><span class="line">    ~StrVec(); <span class="comment">// destructor</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)</span></span>; <span class="comment">// copy the element</span></span><br><span class="line">    <span class="keyword">size_t</span> size() <span class="keyword">const</span> &#123; <span class="keyword">return</span> first_free - elements; &#125;</span><br><span class="line">    <span class="keyword">size_t</span> capacity() <span class="keyword">const</span> &#123; <span class="keyword">return</span> cap - elements; &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> *<span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> elements; &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> *<span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> first_free; &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::allocator&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; alloc; <span class="comment">// allocates the elements</span></span><br><span class="line">    <span class="comment">// used by the functions that add elements to the StrVec</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">chk_n_alloc</span><span class="params">()</span></span>&#123; <span class="keyword">if</span> (size() == capacity()) reallocate(); &#125;</span><br><span class="line">    <span class="comment">// utilities used by the copy constructor, assignment operator, and destructor</span></span><br><span class="line">    <span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">string</span>*, <span class="built_in">std</span>::<span class="built_in">string</span>*&gt; alloc_n_copy (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>*, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>*);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">()</span></span>; <span class="comment">// destroy the elements and free the space</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reallocate</span><span class="params">()</span></span>; <span class="comment">// get more space and copy the existing elements</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *elements; <span class="comment">// pointer to the first element in the array</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *first_free; <span class="comment">// pointer to the first free element in the array</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *cap; <span class="comment">// pointer to one past the end of the array</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2 <font color="#ff0000" size="4">注意上述代码private下第一行，这个分配元素的alloc（我称之为构造器）是static的，是属于类的，是所有对象共享的。这个并不影响各个对象的状态，所以感觉声明为static貌似是可行的（尽管直观上我们会觉得每一个对象拥有一个构造器）可以这样理解，它就是一个工人，为各个对象开疆拓土，他听命于所有的对象，但是却仅属于类，你对他下达的命令将会影响你所拥有的的领域的大小，你不会去改变一个工人，你只会从类那里借来使用。</font></p>
<p>3 注意拷贝赋值运算符:注意这里的操作，其实是先在alloc_n_copy()中拷贝了一份，然后才将左侧运算对象指向了新的拷贝，也就是说左侧运算对象与右侧对象在赋值运算符后是相互独立的（如果没有注意alloc_n_copy函数可能会误认为左侧的指针指向了右侧运算对象的内存空间）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">StrVec &amp;StrVec::<span class="keyword">operator</span>=(<span class="keyword">const</span> StrVec &amp;rhs)&#123;</span><br><span class="line">    <span class="comment">// call alloc_n_copy to allocate exactly as many elements as in rhs</span></span><br><span class="line">    <span class="keyword">auto</span> data = alloc_n_copy(rhs.begin(), rhs.end());</span><br><span class="line">    <span class="built_in">free</span>();</span><br><span class="line">    elements = data.first;</span><br><span class="line">    first_free = cap = data.second;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4 在重新分配内存的过程中<strong>移动</strong>而不是拷贝元素：考虑我们的reallocate函数，该函数的目的是拓展容量，我们现在的做法是构造新的大容量空间，然后将原先的内容拷贝至这块新空间的前半部分，再然后销毁原先的空间。这个操作会引起一个旧内存到新内存的string的逐个拷贝。现在考虑普通情况下的拷贝，例如a=b,此时我们将会有两个对象都可用（书中说的是用户）。但是在我们的reallocate函数中，我们的拷贝工作完成后，被拷贝的原对像就不要了，只会保留新的左侧对象（书中说的是用户）。这样的拷贝操作很浪费资源，如果有一种操作是将右侧内存内容<strong>移动</strong>（c++11）到左侧对象的内存，避免分配与释放string的额外操作，性能会好很多。</p>
<p>5 移动构造函数和std::move：C++11中提供了两种机制来避免string的拷贝（针对此问题）。</p>
<ul>
<li>其一：一些标准库类，包含string在内。都定义了所谓的<strong>移动构造函数</strong>，它的实现细节尚未公开（书中原话）。移动构造函数是将资源从给定对象“移动”到正在创建的对象。而且，标准库保证了移动后的源（moved-from）string依然是有效的，可析构的状态（也就是说，尽管我们明面上说的是移动，但是实际上也是一种特殊的拷贝工作，它的代价更低，<strong>且不会破坏源</strong>）。</li>
<li>其二：我们使用名为move的标准库函数，该函数定义在utility头文件中，该函数会使用相应类型的移动构造函数。</li>
</ul>
<p>6 通过上面的分析，我们就可以书写我们想要的reallocate成员了，具体如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> StrVec::reallocate()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> newcapacity = size() ? <span class="number">2</span> * size() : <span class="number">1</span>;<span class="comment">//两倍于现在空间大小的空间</span></span><br><span class="line">    <span class="keyword">auto</span> newdata = alloc.allocate(newcapacity);<span class="comment">//分配内存</span></span><br><span class="line">    <span class="comment">// move the data from the old memory to the new</span></span><br><span class="line">    <span class="keyword">auto</span> dest = newdata; <span class="comment">//指针指向新内存的下一个空闲位置</span></span><br><span class="line">    <span class="keyword">auto</span> elem = elements; <span class="comment">//指针指向旧内存的下一个空闲位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != size(); ++i)</span><br><span class="line">        alloc.construct(dest++, <span class="built_in">std</span>::move(*elem++));<span class="comment">//移动操作</span></span><br><span class="line">    <span class="built_in">free</span>(); <span class="comment">// free the old space once we've moved the elements</span></span><br><span class="line">    <span class="comment">//更新数据结构</span></span><br><span class="line">    elements = newdata;</span><br><span class="line">    first_free = dest;</span><br><span class="line">    cap = elements + newcapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7 由于使用了移动构造函数，<strong>这些string管理的内存将不会拷贝。相反，构造的每个string都会从elem指向的string那里接管内存的所有权</strong>。在这之后，free旧内存，<strong>我们不知道旧内存string包含啥值，但我们保证string的析构函数是安全的（神奇而又秘密的技术）</strong>。</p>
<p>8 <font color="#ff0000" size="4">上述技术还真不好找一个可以类比的例子来解释，大致讲述一下。一方面，原文中提到了对了内存的所有权的交接，这可以理解为移动的特性（可能就是这种方式实现的）；但是另一方面，我们又说到了，在移动操作之后，源是保留的，不会被破坏的，我们可以在上面进行析构操作（这种行为有很类似拷贝，因为拷贝的结果就是二者独立，且这种结果是与权力转移的描述有矛盾的）。所以，这种操作还真挺神秘的，它兼具两钟操作的特性（像是波粒二象性）。我倾向于把他理解我兼具二者特性的未知秘密，具体这个秘密是啥，有待之后的公开。</font></p>
<h1 id="六-对象移动-C-11"><a href="#六-对象移动-C-11" class="headerlink" title="六.对象移动(C++11)"></a>六.对象移动(C++11)</h1><p>1 使用移动而不是拷贝不仅出于对效率的考虑（一些源在拷贝以后就弃用了，浪费），另一个原因是IO类或者unique_ptr类本身就是不可被拷贝的（包含不可被共享的资源）。但是它们可以进行移动操作。</p>
<p>2 旧版本的标准库中，容器保存的类必须是可拷贝的，<strong>但是在新标准中，可以用容器保存不可拷贝的类型，只要它们能被移动即可</strong>。</p>
<p>3 右值引用：就是绑定到右值的引用，这是一种新引用类型，是为了支持移动操作而引入的。通过使用&amp;&amp;来获得右值引用，<strong>右值引用只能绑定到一个将要销毁的对象，因此我们可以自由地将一个右值引用的资源“移动”到另一个对象中（因为即将销毁了啊，不会再用了啊，所以可以移动了）</strong>。</p>
<p>4 我们可以将右值引用绑定到右值上（要求转换的表达式，字面常量，返回右值的表达式），但是不能将右值引用绑定到一个左值上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r = i; <span class="comment">// ok: r refers to i</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr = i; <span class="comment">// error: cannot bind an rvalue reference to an lvalue</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2 = i * <span class="number">42</span>; <span class="comment">// error: i * 42 is an rvalue</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = i * <span class="number">42</span>; <span class="comment">//常量引用可以绑定在右值上</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr2= i * <span class="number">42</span>; <span class="comment">//右值引用</span></span><br></pre></td></tr></table></figure>
<p>5 几个例子</p>
<ul>
<li>返回左值的情况：<ul>
<li>赋值</li>
<li>下标</li>
<li>解引用</li>
<li>前置递增/递减运算符</li>
</ul>
</li>
<li>返回右值的情况：<ul>
<li>算术</li>
<li>关系</li>
<li>位</li>
<li>后置递增/递减运算符</li>
</ul>
</li>
<li>可以将常量引用或者右值引用绑定在右值上。</li>
</ul>
<p>6 左值持久，右值短暂：左值有持久的状态，右值要么是字面常量，要么是表达式求值过程中创建的<strong>临时对象</strong>。右值引用只能绑定在临时对象，所以：使用右值引用的代码可以自由接管所引用对象的资源。</p>
<ul>
<li>所引用对象将要被销毁</li>
<li>该对象没有其他用户</li>
</ul>
<p>6 变量是左值，不能将右值引用直接绑定在一个变量上。</p>
<p>7 标准库的move函数：虽然不能将右值引用绑定在左值上，<strong>但我们可以显示地将一个左值转换为对应的右值引用类型，也可以使用标准库的move函数来获得绑定到左值上的右值引用</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;rr3 = <span class="built_in">std</span>::move(rr1); <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<p>8 <font color="#ff0000" size="4">警告：调用move函数旧意味着程序员做出了一种承诺：“除去赋值操作（意义不大）与销毁操作，我将不会再使用（读取）rr1。”所以调用了move函数之后，我们就不再对源对象的值有任何期望。出于后面介绍的原因，我们一般直接调用std::move而不进行using声明（可能是std::move就是我们想要的,我们可能不定义也不使用自定义的move）</font></p>
<p>9 移动构造函数与移动赋值运算符</p>
<p>p473<br>【尚未完结】</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-03-29</span><i class="fa fa-tag"></i><a class="tag" href="/categories/C/" title="C++">C++ </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://yoursite.com/2018/03/29/Chapter13_拷贝控制/,Hailu's Blog,《C++ Primer 5》Chapter13读书笔记,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2018/03/30/Chapter0&amp;1_计科概论&amp;Linux初识/" title="《鸟哥的Linux私房菜基础篇》Chapter0&amp;1读书笔记">Post Anterior</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2018/03/29/Chapter7_类/" title="《C++ Primer 5》Chapter7读书笔记">Próximo post</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>