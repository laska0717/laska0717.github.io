<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Hailu"><title>《鸟哥的Linux私房菜基础篇》Chapter6读书笔记 · Hailu's Blog</title><meta name="description" content="Linux文件与目录管理目录与路径1 绝对路径：路径的写法“一定由根目录/ 写起”，例如：/usr/share/doc 这个目录；相对路径：路径的写法“不是由/ 写起”，例如由/usr/share/doc 要到/usr/share/man 下面时，可以写成：“cd ../man”。
2 变换目录的指"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Hailu's Blog</a></h3><div class="description"><p>53696C656E636520697320676F6C64</p></div></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">Home</a></li><li><a href="/archives">Arquivo</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>《鸟哥的Linux私房菜基础篇》Chapter6读书笔记</a></h3></div><div class="post-content"><h1 id="Linux文件与目录管理"><a href="#Linux文件与目录管理" class="headerlink" title="Linux文件与目录管理"></a>Linux文件与目录管理</h1><h2 id="目录与路径"><a href="#目录与路径" class="headerlink" title="目录与路径"></a>目录与路径</h2><p>1 绝对路径：路径的写法“一定由根目录/ 写起”，例如：/usr/share/doc 这个目录；相对路径：路径的写法“不是由/ 写起”，例如由/usr/share/doc 要到/usr/share/man 下面时，可以写成：“cd ../man”。</p>
<p>2 变换目录的指令是cd</p>
<p>3 比较特殊的目录：</p>
<ul>
<li>符号.代表此层目录</li>
<li>符号..代表上一层目录</li>
<li>符号-代表前一个工作目录</li>
<li>符号~代表“目前使用者身份”所在的主文件夹</li>
<li>符号~account代表account 这个使用者的主文件夹（account是个帐号名称）</li>
</ul>
<p>4 根目录下有没有上层目录（..）存在？根目录的上一层（..）与根目录自己（.）是同一个目录</p>
<p>5 常见指令：</p>
<ul>
<li>cd：变换目录</li>
<li>pwd：显示目前的目录</li>
<li>mkdir：创建一个新的目录</li>
<li>rmdir：删除一个空的目录</li>
<li>cd：变换目录</li>
</ul>
<p>6 一登陆Linux系统后，每个帐号都会在自己帐号的主文件夹中</p>
<p>7 如果仅输入cd 时，代表的就是“ cd ~ ”的意思喔～亦即是会回到自己的主文件夹</p>
<p>8 pwd [-P]：参数-P是显示出确实的路径，而非使用链接（link）路径。加上pwd -P 的选项后，会不以链接文件的数据显示，而是显示正确的完整路径。</p>
<p>9 mkdir （创建新目录），mkdir [-mp] 目录名称</p>
<ul>
<li>符号-m ：设置文件的权限喔！直接设置，不需要看默认权限（umask）的脸色。例如mkdir -m 711 test2</li>
<li>符号-p ：帮助你直接将所需要的目录（包含上层目录）递回创建起来！例如mkdir -p test1/test2</li>
</ul>
<p>10 rmdir [-p] 目录名称</p>
<ul>
<li>符号-p ：连同“上层”“空的”目录也一起删除：这个是说，如果有a/b/c这样的目录（且唯一，无其他文件），rmdir a将会无效，因为rmdir只删除空目录；需要写成 rmdir -p a/b/c这样子，才可以由里及外一层层的将这个目录树删除干净。但是必须要写清楚这棵树。</li>
</ul>
<p>11 如果要将所有目录下的东西都杀掉呢？！这个时候就必须使用“ rm -r test</p>
<p>12 我们知道查阅文件属性的指令ls完整文件名为：/bin/ls（这是绝对路径），那你会不会觉得很奇怪：“为什么我可以在任何地方执行/bin/ls这个指令呢，为什么我在任何目录下输入ls 就一定可以显示出一些讯息而不会说找不到该/bin/ls 指令呢。这是因为有<strong>环境变量PATH</strong>的帮助。</p>
<p>13 在执行一个指令的时候，举例来说“ls”好了，系统会依照PATH的设置去每个PATH定义的目录下搜寻文件名为ls的可可执行文件，如果在PATH定义的目录中含有多个文件名为ls的可执行文件，那么先搜寻到的同名指令先被执行。“echo $PATH”来看看到底有哪些目录被定义。</p>
<p>14 不同身份使用者默认的PATH不同；PATH是可以修改；使用绝对路径或相对路径直接指定某个指令的文件名来执行，会比搜寻PATH来的正确；指令应该要放置到正确的目录下，执行才会比较方便；本目录（.）最好不要放到PATH当中</p>
<h2 id="文件与目录管理"><a href="#文件与目录管理" class="headerlink" title="文件与目录管理"></a>文件与目录管理</h2><p>1 文件与目录的检视：ls</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# ls [-aAdfFhilnrRSt] 文件名或目录名称..</span><br><span class="line">[root@study ~]# ls [--color=&#123;never,auto,always&#125;] 文件名或目录名称..</span><br><span class="line">[root@study ~]# ls [--full-time] 文件名或目录名称..</span><br><span class="line">选项与参数：</span><br><span class="line">-a ：全部的文件，连同隐藏文件（开头为. 的文件）一起列出来（常用）</span><br><span class="line">-A ：全部的文件，连同隐藏文件，但不包括. 与.. 这两个目录</span><br><span class="line">-d ：仅列出目录本身，而不是列出目录内的文件数据（常用）</span><br><span class="line">-f ：直接列出结果，而不进行排序（ls 默认会以文件名排序！）</span><br><span class="line">-F ：根据文件、目录等信息，给予附加数据结构，例如：</span><br><span class="line">*:代表可可执行文件；/:代表目录；=:代表socket 文件；&amp;#124;:代表FIFO 文件；</span><br><span class="line">-h ：将文件大小以人类较易读的方式（例如GB, KB 等等）列出来；</span><br><span class="line">-i ：列出inode 号码，inode 的意义下一章将会介绍；</span><br><span class="line">-l ：长数据串行出，包含文件的属性与权限等等数据；（常用）</span><br><span class="line">-n ：列出UID 与GID 而非使用者与群组的名称（UID与GID会在帐号管理提到！）</span><br><span class="line">-r ：将排序结果反向输出，例如：原本文件名由小到大，反向则为由大到小；</span><br><span class="line">-R ：连同子目录内容一起列出来，等于该目录下的所有文件都会显示出来；</span><br><span class="line">-S ：以文件大小大小排序，而不是用文件名排序；</span><br><span class="line">-t ：依时间排序，而不是用文件名。</span><br><span class="line">--color=never ：不要依据文件特性给予颜色显示；</span><br><span class="line">--color=always ：显示颜色</span><br><span class="line">--color=auto ：让系统自行依据设置来判断是否给予颜色</span><br><span class="line">--full-time ：以完整时间模式（包含年、月、日、时、分）输出</span><br><span class="line">--time=&#123;atime,ctime&#125; ：输出access 时间或改变权限属性时间（ctime）而非内容变更时间（modification time）</span><br></pre></td></tr></table></figure>
<p>2 复制cp，复制文件，请使用cp （copy）这个指令。这个指令除了单纯的复制之外，还可以创建链接文件（就是快捷方式）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# cp [-adfilprsu] 来源文件（source）目标文件（destination）</span><br><span class="line">[root@study ~]# cp [options] source1 source2 source3 .... directory</span><br><span class="line">选项与参数：</span><br><span class="line">-a ：相当于-dr --preserve=all 的意思，至于dr 请参考下列说明；（常用）</span><br><span class="line">-d ：若来源文件为链接文件的属性（link file），则复制链接文件属性而非文件本身；</span><br><span class="line">-f ：为强制（force）的意思，若目标文件已经存在且无法打开，则移除后再尝试一次；</span><br><span class="line">-i ：若目标文件（destination）已经存在时，在覆盖时会先询问动作的进行（常用）</span><br><span class="line">-l ：进行硬式链接（hard link）的链接文件创建，而非复制文件本身；</span><br><span class="line">-p ：连同文件的属性（权限、用户、时间）一起复制过去，而非使用默认属性（备份常用）；</span><br><span class="line">-r ：递回持续复制，用于目录的复制行为；（常用）</span><br><span class="line">-s ：复制成为符号链接文件（symbolic link），亦即“捷径”文件；</span><br><span class="line">-u ：destination 比source 旧才更新destination，或destination 不存在的情况下才复制。</span><br><span class="line">--preserve=all ：除了-p 的权限相关参数外，还加入SELinux 的属性, links, xattr 等也复制了。</span><br><span class="line">最后需要注意的，如果来源文件有两个以上，则最后一个目的文件一定要是“目录”才行！</span><br></pre></td></tr></table></figure>
<p>3 我们如果去复制别人的数据（当然，该文件你必须要有read的权限才行）时，总是希望复制到的数据最后是我们自己的，所以，在默认的条件中，cp的来源文件与目的文件的权限是不同的，目的文件的拥有者通常会是指令操作者本身。某些需要特别注意的特殊权限文件，例如密码档（/etc/shadow）以及一些配置文件，就不能直接以cp 来复制，而必须要加上-a或者是-p 等等可以完整复制文件权限的选项才行。</p>
<p>4 实体链接与符号链接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@study tmp]# ls -l bashrc</span><br><span class="line">-rw-r--r--. 1 root root 176 Jun 11 19:01 bashrc &amp;lt;==先观察一下文件情况</span><br><span class="line">[root@study tmp]# cp -s bashrc bashrc_slink</span><br><span class="line">[root@study tmp]# cp -l bashrc bashrc_hlink</span><br><span class="line">[root@study tmp]# ls -l bashrc*</span><br><span class="line">-rw-r--r--. 2 root root 176 Jun 11 19:01 bashrc &amp;lt;==与原始文件不太一样了！</span><br><span class="line">-rw-r--r--. 2 root root 176 Jun 11 19:01 bashrc_hlink</span><br><span class="line">lrwxrwxrwx. 1 root root 6 Jun 11 19:06 bashrc_slink -&amp;gt; bashrc</span><br><span class="line"></span><br><span class="line">使用-l 及-s 都会创建所谓的链接文件（link file），但是这两种链接文件却有不一样的情况。这是怎么一回事啊？那个-l 就是所谓的实体链接（hard link），至于-s 则是符号链接（symbolic link），简单来说，bashrc_slink 是一个“捷径”，这个捷径会链接到bashrc去！所以你会看到文件名右侧会有个指向（-&gt;）的符号！至于bashrc_hlink文件与bashrc的属性与权限完全一模一样，与尚未进行链接前的差异则是第二栏的link数由1变成2了。</span><br></pre></td></tr></table></figure>
<p>5 另外一个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">范例六：将范例四造成的bashrc_slink 复制成为bashrc_slink_1 与bashrc_slink_2</span><br><span class="line">[root@study tmp]# cp bashrc_slink bashrc_slink_1</span><br><span class="line">[root@study tmp]# cp -d bashrc_slink bashrc_slink_2</span><br><span class="line">[root@study tmp]# ls -l bashrc bashrc_slink*</span><br><span class="line">-rw-r--r--. 2 root root 176 Jun 11 19:01 bashrc</span><br><span class="line">lrwxrwxrwx. 1 root root 6 Jun 11 19:06 bashrc_slink -&amp;gt; bashrc</span><br><span class="line">-rw-r--r--. 1 root root 176 Jun 11 19:09 bashrc_slink_1 &amp;lt;==与原始文件相同</span><br><span class="line">lrwxrwxrwx. 1 root root 6 Jun 11 19:10 bashrc_slink_2 -&amp;gt; bashrc &amp;lt;==是链接文件！</span><br><span class="line"># 这个例子也是很有趣喔！原本复制的是链接文件，但是却将链接文件的实际文件复制过来了</span><br><span class="line"># 也就是说，如果没有加上任何选项时，cp复制的是原始文件，而非链接文件的属性！</span><br><span class="line"># 若要复制链接文件的属性，就得要使用-d 的选项了！如bashrc_slink_2 所示。</span><br></pre></td></tr></table></figure>
<p>6 多文件复制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">范例七：将主文件夹的.bashrc 及.bash_history 复制到/tmp 下面</span><br><span class="line">[root@study tmp]# cp ~/.bashrc ~/.bash_history /tmp</span><br><span class="line"># 可以将多个数据一次复制到同一个目录去！最后面一定是目录！</span><br></pre></td></tr></table></figure>
<p>7 rm移除文件或目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# rm [-fir] 文件或目录</span><br><span class="line">选项与参数：</span><br><span class="line">-f ：就是force 的意思，忽略不存在的文件，不会出现警告讯息；</span><br><span class="line">-i ：互动模式，在删除前会询问使用者是否动作</span><br><span class="line">-r ：递回删除啊！最常用在目录的删除了！这是非常危险的选项！！！</span><br></pre></td></tr></table></figure>
<p>8 例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">范例二：通过万用字符*的帮忙，将/tmp下面开头为bashrc的文件名通通删除：</span><br><span class="line">[root@study tmp]# rm -i bashrc*</span><br><span class="line"># 注意那个星号，代表的是0 到无穷多个任意字符喔！很好用的东西</span><br></pre></td></tr></table></figure>
<p>9 另一个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@study tmp]# \rm -r /tmp/etc</span><br><span class="line"># 在指令前加上反斜线，可以忽略掉alias 的指定选项喔！至于alias 我们在bash再谈</span><br></pre></td></tr></table></figure>
<p>10 删除一个-开头的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@study tmp]# rm -aaarm:</span><br><span class="line">invalid option -- &apos;a&apos; &amp;lt;== 因为&quot;-&quot; 是选项嘛！所以系统误判了！</span><br><span class="line">Try &apos;rm ./-aaa-&apos; to remove the file `-aaa-&apos;. &amp;lt;== 新的bash 有给建议的</span><br><span class="line">Try &apos;rm --help&apos; for more information.</span><br><span class="line">[root@study tmp]# rm ./-aaa-</span><br><span class="line">其实还有一种方法，那就是“ rm -- -aaa- ”也可以</span><br></pre></td></tr></table></figure>
<p>11 mv （移动文件与目录，或更名）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# mv [-fiu] source destination</span><br><span class="line">[root@study ~]# mv [options] source1 source2 source3 .... directory</span><br><span class="line">选项与参数：</span><br><span class="line">-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</span><br><span class="line">-i ：若目标文件（destination）已经存在时，就会询问是否覆盖！</span><br><span class="line">-u ：若目标文件已经存在，且source 比较新，才会更新（update）</span><br></pre></td></tr></table></figure>
<p>12 例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">范例二：将刚刚的目录名称更名为mvtest2</span><br><span class="line">[root@study tmp]# mv mvtest mvtest2 &amp;lt;== 这样就更名了！简单～</span><br><span class="line"># 其实在Linux 下面还有个有趣的指令，名称为rename ，</span><br><span class="line"># 该指令专职进行多个文件名的同时更名，并非针对单一文件名变更，与mv不同。请man rename</span><br></pre></td></tr></table></figure>
<p>13 取得路径的文件名称与目录名称，每个文件的完整文件名包含了前面的目录与最终的文件名，而每个文件名的长度都可以到达255 个字符耶！那么你怎么知道那个是文件名？那个是目录名？嘿嘿！就是利用斜线（/）来分辨。</p>
<ul>
<li>basename 与dirname 的用途！：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# basename /etc/sysconfig/network</span><br><span class="line">network &amp;lt;== 很简单！就取得最后的文件名～</span><br><span class="line">[root@study ~]# dirname /etc/sysconfig/network</span><br><span class="line">/etc/sysconfig &amp;lt;== 取得的变成目录名了！</span><br></pre></td></tr></table></figure>
<h2 id="文件内容查阅"><a href="#文件内容查阅" class="headerlink" title="文件内容查阅"></a>文件内容查阅</h2><p>1 常用查阅指令介绍</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat 由第一行开始显示文件内容</span><br><span class="line">tac 从最后一行开始显示，可以看出tac 是cat 的倒着写！</span><br><span class="line">nl 显示的时候，顺道输出行号！</span><br><span class="line">more 一页一页的显示文件内容</span><br><span class="line">less 与more 类似，但是比more 更好的是，他可以往前翻页！</span><br><span class="line">head 只看头几行</span><br><span class="line">tail 只看尾巴几行</span><br><span class="line">od 以二进制的方式读取文件内容！</span><br></pre></td></tr></table></figure>
<p>2 cat与nl详细用法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# cat [-AbEnTv]</span><br><span class="line">选项与参数：</span><br><span class="line">-A ：相当于-vET 的整合选项，可列出一些特殊字符而不是空白而已；</span><br><span class="line">-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</span><br><span class="line">-E ：将结尾的断行字符$ 显示出来；</span><br><span class="line">-n ：打印出行号，连同空白行也会有行号，与-b 的选项不同；</span><br><span class="line">-T ：将[tab] 按键以^I 显示出来；</span><br><span class="line">-v ：列出一些看不出来的特殊字符</span><br><span class="line"></span><br><span class="line">[root@study ~]# nl [-bnw] 文件</span><br><span class="line">选项与参数：</span><br><span class="line">-b ：指定行号指定的方式，主要有两种：</span><br><span class="line">-b a ：表示不论是否为空行，也同样列出行号（类似cat -n）；</span><br><span class="line">-b t ：如果有空行，空的那一行不要列出行号（默认值）；</span><br><span class="line">-n ：列出行号表示的方法，主要有三种：</span><br><span class="line">-n ln ：行号在屏幕的最左方显示；</span><br><span class="line">-n rn ：行号在自己字段的最右方显示，且不加0 ；</span><br><span class="line">-n rz ：行号在自己字段的最右方显示，且加0 ；</span><br><span class="line">-w ：行号字段的占用的字符数。</span><br></pre></td></tr></table></figure>
<p>3 可翻页检查more与less</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">more （一页一页翻动）</span><br><span class="line">[root@study ~]# more /etc/man_db.conf</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"># This file is used by the man-db package to configure the man and cat paths.</span><br><span class="line"># It is also used to provide a manpath for those without one by examining</span><br><span class="line"># their PATH environment variable. For details see the manpath（5）man page.</span><br><span class="line">#</span><br><span class="line">.....（中间省略）.....</span><br><span class="line">--More--（28%）&amp;lt;== 重点在这一行喔！你的光标也会在这里等待你的指令</span><br><span class="line">在more 这个程序的运行过程中，你有几个按键可以按的:</span><br><span class="line">空白键（space）：代表向下翻一页；</span><br><span class="line">Enter ：代表向下翻“一行”；</span><br><span class="line">/字串：代表在这个显示的内容当中，向下搜寻“字串”这个关键字；</span><br><span class="line">:f ：立刻显示出文件名以及目前显示的行数；</span><br><span class="line">q ：代表立刻离开more ，不再显示该文件内容。</span><br><span class="line">b 或[ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">[root@study ~]# less /etc/man_db.conf</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line"># This file is used by the man-db package to configure the man and cat paths.</span><br><span class="line"># It is also used to provide a manpath for those without one by examining</span><br><span class="line"># their PATH environment variable. For details see the manpath（5）man page.</span><br><span class="line">#</span><br><span class="line">.....（中间省略）.....</span><br><span class="line">: &amp;lt;== 这里可以等待你输入指令！</span><br><span class="line">less 的用法比起more 又更加的有弹性，怎么说呢？在more 的时候，我们并没有办法向前面翻，只能往后面看，但若使用了less 时，呵呵！就可以使用[pageup] [pagedown] 等按键的功能来往前往后翻看文件。</span><br><span class="line">在less 里头可以拥有更多的“搜寻”功能：</span><br><span class="line">空白键：向下翻动一页；</span><br><span class="line">[pagedown]：向下翻动一页；</span><br><span class="line">[pageup] ：向上翻动一页；</span><br><span class="line">/字串：向下搜寻“字串”的功能；</span><br><span class="line">?字串：向上搜寻“字串”的功能；</span><br><span class="line">n ：重复前一个搜寻（与/ 或? 有关！）</span><br><span class="line">N ：反向的重复前一个搜寻（与/ 或? 有关！）</span><br><span class="line">g ：前进到这个数据的第一行去；</span><br><span class="line">G ：前进到这个数据的最后一行去（注意大小写）；</span><br><span class="line">q ：离开less 这个程序；</span><br></pre></td></tr></table></figure>
<p>4 数据撷取，可以将输出的数据作一个最简单的撷取，那就是取出文件前面几行（head）或取出后面几行（tail）文字的功能。不过，要注意的是，head 与tail 都是以“行”为单位来进行数据撷取的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">head （取出前面几行）</span><br><span class="line">[root@study ~]# head [-n number] 文件</span><br><span class="line">选项与参数：</span><br><span class="line">-n ：后面接数字，代表显示几行的意思</span><br><span class="line">那个-n 选项后面的参数较有趣，如果接的是负数，例如上面范例的-n -100时，代表列前的所有行数，但不包括后面100行</span><br><span class="line">[root@study ~]# head /etc/man_db.conf</span><br><span class="line"># 默认的情况中，显示前面十行！若要显示前20 行，就得要这样：</span><br><span class="line">[root@study ~]# head -n 20 /etc/man_db.conf</span><br><span class="line">范例：如果后面100行的数据都不打印，只打印/etc/man_db.conf的前面几行，该如何是好？</span><br><span class="line">[root@study ~]# head -n -100 /etc/man_db.conf</span><br><span class="line">------------------------------------------------------------------------------------------------</span><br><span class="line">tail （取出后面几行）</span><br><span class="line">[root@study ~]# tail [-n number] 文件</span><br><span class="line">选项与参数：</span><br><span class="line">-n ：后面接数字，代表显示几行的意思</span><br><span class="line">-f ：表示持续侦测后面所接的文件名，要等到按下[ctrl]-c才会结束tail的侦测</span><br><span class="line">由于/var/log/messages随时会有数据写入，你想要让该文件有数据写入时就立刻显示到屏幕上，就利用-f 这个选项，他可以一直侦测/var/log/messages这个文件，新加入的数据都会被显示到屏幕上。直到你按下[crtl]-c才会离开tail的侦测喔！由于messages 必须要root 权限才能看，所以该范例得要使用root 来查询。</span><br><span class="line">[root@study ~]# tail /etc/man_db.conf</span><br><span class="line"># 默认的情况中，显示最后的十行！若要显示最后的20 行，就得要这样：</span><br><span class="line">[root@study ~]# tail -n 20 /etc/man_db.conf</span><br><span class="line">范例一：如果不知道/etc/man_db.conf有几行，却只想列出100行以后的数据时？</span><br><span class="line">[root@study ~]# tail -n +100 /etc/man_db.conf</span><br><span class="line">范例二：持续侦测/var/log/messages的内容</span><br><span class="line">[root@study ~]# tail -f /var/log/messages</span><br><span class="line">&amp;lt;==要等到输入[crtl]-c之后才会离开tail这个指令的侦测！</span><br></pre></td></tr></table></figure>
<p>5 假如我想要显示/etc/man_db.conf 的第11 到第20 行呢？，head -n 20/etc/man_db.conf | tail -n 10 ”，这样就可以得到第11 到第20 行之间的内容了。这两个指令中间有个管线（|）的符号存在，这个管线的意思是：“前面的指令所输出的讯息，请通过管线交由后续的指令继续使用”的意思。所以，head -n 20 /etc/man_db.conf 会将文件内的20 行取出来，但不输出到屏幕上，而是转交给后续的tail 指令继续处理。</p>
<p>6 使用od指令查看非纯文本文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# od [-t TYPE] 文件</span><br><span class="line">选项或参数：</span><br><span class="line">-t ：后面可以接各种“类型（TYPE）”的输出，例如：</span><br><span class="line">a ：利用默认的字符来输出；</span><br><span class="line">c ：使用ASCII 字符来输出</span><br><span class="line">d[size] ：利用十进制（decimal）来输出数据，每个整数占用size Bytes ；</span><br><span class="line">f[size] ：利用浮点数值（floating）来输出数据，每个数占用size Bytes ；</span><br><span class="line">o[size] ：利用八进位（octal）来输出数据，每个整数占用size Bytes ；</span><br><span class="line">x[size] ：利用十六进制（hexadecimal）来输出数据，每个整数占用size Bytes ；</span><br><span class="line"></span><br><span class="line">范例二：请将/etc/issue这个文件的内容以8进位列出储存值与ASCII的对照表</span><br><span class="line">[root@study ~]# od -t oCc /etc/issue</span><br><span class="line">0000000 134 123 012 113 145 162 156 145 154 040 134 162 040 157 156 040</span><br><span class="line">\ S \n K e r n e l \ r o n</span><br><span class="line">0000020 141 156 040 134 155 012 012</span><br><span class="line">a n \ m \n \n</span><br><span class="line">0000027</span><br><span class="line"># 如上所示，可以发现每个字符可以对应到的数值为何！要注意的是，该数值是8 进位喔！</span><br><span class="line"># 例如S 对应的记录数值为123 ，转成十进制：1x8^2+2x8+3=83。</span><br></pre></td></tr></table></figure>
<p>7 修改文件时间或者是创建文件：touch。每个文件在linux下面都会记录许多的时间参数，其实是有三个主要的变动时间：</p>
<ul>
<li>modification time （mtime）：当该文件的“内容数据”变更时，就会更新这个时间！内容数据指的是文件的内容，而不是文件的属性或权限。ls 显示出来的是该文件的mtime </li>
<li>当该文件的“状态（status）”改变时，就会更新这个时间，举例来说，像是权限与属性被更改了，都会更新这个时间。</li>
<li>access time （atime）：当“该文件的内容被取用”时，就会更新这个读取时间（access）。举例来说，我们使用cat 去读取/etc/man_db.conf ，就会更新该文件的atime。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# touch [-acdmt] 文件</span><br><span class="line">选项与参数：</span><br><span class="line">没有参数表示创建一个文件；</span><br><span class="line">-a ：仅修订access time；</span><br><span class="line">-c ：仅修改文件的时间，若该文件不存在则不创建新文件；</span><br><span class="line">-d ：后面可以接欲修订的日期而不用目前的日期，也可以使用--date=&quot;日期或时间&quot;</span><br><span class="line">-m ：仅修改mtime ；</span><br><span class="line">-t ：后面可以接欲修订的时间而不用目前的时间，格式为[YYYYMMDDhhmm]</span><br><span class="line"></span><br><span class="line">范例三：修改案例二的bashrc 文件，将日期调整为两天前</span><br><span class="line">[dmtsai@study tmp]# touch -d &quot;2 days ago&quot; bashrc</span><br><span class="line">范例四：将上个范例的bashrc 日期改为2014/06/15 2:02</span><br><span class="line">[dmtsai@study tmp]# touch -t 201406150202 bashrc</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="文件与目录的默认权限与隐藏权限"><a href="#文件与目录的默认权限与隐藏权限" class="headerlink" title="文件与目录的默认权限与隐藏权限"></a>文件与目录的默认权限与隐藏权限</h2><p>在Linux传统的Ext2/Ext3/Ext4文件系统下，我们还可以设置其他的系统隐藏属性，这部份可使用chattr 来设置，而以lsattr 来查看，最重要的属性就是可以设置其不可修改的特性！让连文件的拥有者都不能进行修改！这个属性可是相当重要的，尤其是在安全机制上面（security）！比较可惜的是，在CentOS 7.x 当中利用xfs 作为默认文件系统，但是xfs 就没有支持所有的chattr 的参数了！仅有部份参数还有支持而已。</p>
<p>1 文件默认权限umask：当你创建一个新的文件或目录时，他的默认权限会是什么。umask 就是指定“目前使用者在创建文件或目录时候的权限默认值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查阅的方式有两种，一种可以直接输入umask ，就可以看到数字体态的权限设置分数，一种则是加入-S （Symbolic）这个选项，就会以符号类型的方式来显示出权限了！奇怪的是，怎么umask 会有四组数字啊？不是只有三组吗？是没错啦。第一组是特殊权限用的，我们先不要理他。</span><br><span class="line">[root@study ~]# umask</span><br><span class="line">0022 &amp;lt;==与一般权限有关的是后面三个数字！</span><br><span class="line">[root@study ~]# umask -S</span><br><span class="line">u=rwx,g=rx,o=rx</span><br></pre></td></tr></table></figure>
<p>2 若使用者创建为“文件”则默认“没有可执行（x ）权限”，亦即只有rw 这两个项目，也就是最大为666 分，默认权限如下：-rw-rw-rw-；若使用者创建为“目录”，则由于x 与是否可以进入此目录有关，因此默认为所有权限均开放，亦即为777 分，默认权限如下：drwxrwxrwx。</p>
<p>3 要注意的是，umask 的分数指的是“该默认值需要减掉的权限！”因为r、w、x 分别是4、2、1 分，所以啰！也就是说，当要拿掉能写的权限，就是输入2 分，而如果要拿掉能读的权限，也就是4 分，那么要拿掉读与写的权限，也就是6 分，而要拿掉执行与写入的权限，也就是3 分，这样了解吗？如何设置umask 呢？简单的很，直接在umask 后面输入002就好。</p>
<p>4 默认的情况中，root 的umask 会拿掉比较多的属性，root 的umask 默认是022 ，这是基于安全的考虑啦～至于一般身份使用者，通常他们的umask 为002。</p>
<p>5 文件隐藏属性，下面的chattr指令只能在Ext2/Ext3/Ext4的Linux 传统文件系统上面完整生效，其他的文件系统可能就无法完整的支持这个指令了，例如xfs 仅支持部份参数而已。下面我们就来谈一谈如何设置与检查这些隐藏的属性吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">chattr （设置文件隐藏属性）</span><br><span class="line">chattr [+-=][ASacdistu] 文件或目录名称</span><br><span class="line">选项与参数：</span><br><span class="line">+ ：增加某一个特殊参数，其他原本存在参数则不动。</span><br><span class="line">- ：移除某一个特殊参数，其他原本存在参数则不动。</span><br><span class="line">= ：设定一定，且仅有后面接的参数</span><br><span class="line"></span><br><span class="line">A ：当设定了A 这个属性时，若你有存取此档案(或目录)时，他的存取时间atime 将不会被修改，可避免I/O 较慢的机器过度的存取磁碟。(目前建议使用档案系统挂载参数处理这个项目)</span><br><span class="line">S ：一般档案是非同步写入磁碟的(原理请参考前一章sync的说明)，如果加上S这个属性时，当你进行任何档案的修改，该更动会『同步』写入磁碟中。</span><br><span class="line">a ：当设定a 之后，这个档案将只能增加资料，而不能删除也不能修改资料，只有root 才能设定这属性</span><br><span class="line">c ：这个属性设定之后，将会自动的将此档案『压缩』，在读取的时候将会自动解压缩，但是在储存的时候，将会先进行压缩后再储存(看来对于大档案似乎蛮有用的！)</span><br><span class="line">d ：当dump 程序被执行的时候，设定d 属性将可使该档案(或目录)不会被dump 备份</span><br><span class="line">i ：这个i 可就很厉害了！他可以让一个档案『不能被删除、改名、设定连结也无法写入或新增资料！』对于系统安全性有相当大的助益！只有root 能设定此属性</span><br><span class="line">s ：当档案设定了s 属性时，如果这个档案被删除，他将会被完全的移除出这个硬碟空间，所以如果误删了，完全无法救回来了喔！</span><br><span class="line">u ：与s 相反的，当使用u 来设定档案时，如果该档案被删除了，则资料内容其实还存在磁碟中，可以使用来救援该档案喔！</span><br><span class="line">注意1：属性设定常见的是a 与i 的设定值，而且很多设定值必须要身为root 才能设定</span><br><span class="line">注意2：xfs 档案系统仅支援AadiS 而已</span><br><span class="line"></span><br><span class="line">范例：请尝试到/tmp底下建立档案，并加入i的参数，尝试删除看看。</span><br><span class="line">[root@study ~]# cd /tmp</span><br><span class="line">[root@study tmp]# touch attrtest      &lt;==建立一个空档案</span><br><span class="line">[root@study tmp]# chattr +i attrtest  &lt;==给予i的属性</span><br><span class="line">[root@study tmp] # rm attrtest         &lt;==尝试删除看看</span><br><span class="line">rm: remove regular empty file `attrtest&apos;? y</span><br><span class="line">rm: cannot remove `attrtest&apos;: Operation not permitted</span><br><span class="line"># 看到了吗？呼呼！连root 也没有办法将这个档案删除呢！赶紧解除设定！</span><br><span class="line"></span><br><span class="line">范例：请将该档案的i属性取消！</span><br><span class="line">[root@study tmp]# chattr -i attrtest</span><br></pre></td></tr></table></figure>
<p>6 这个指令是很重要的，尤其是在系统的数据安全上面！由于这些属性是隐藏的性质，所以需要以lsattr 才能看到该属性。</p>
<p>7 lsattr （显示文件隐藏属性）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# lsattr [-adR] 文件或目录</span><br><span class="line">选项与参数：</span><br><span class="line">-a ：将隐藏文件的属性也秀出来；</span><br><span class="line">-d ：如果接的是目录，仅列出目录本身的属性而非目录内的文件名；</span><br><span class="line">-R ：连同子目录的数据也一并列出来！</span><br><span class="line">[root@study tmp]# chattr +aiS attrtest</span><br><span class="line">[root@study tmp]# lsattr attrtest</span><br><span class="line">--S-ia---------- attrtest</span><br></pre></td></tr></table></figure>
<p>8 文件特殊权限SUID, SGID, SBIT：不是应该只有rwx 吗？还有其他的特殊权限</p>
<ul>
<li>当s 这个标志出现在文件拥有者的x 权限上时，例如刚刚提到的/usr/bin/passwd 这个文件的权限状态：“-rwsr-xr-x”，此时就被称为Set UID，简称为SUID 的特殊权限。SUID有这样的限制与功能：<ul>
<li>SUID 权限仅对二进制程序（binary program）有效；</li>
<li>执行者对于该程序需要具有x 的可执行权限；</li>
<li>本权限仅在执行该程序的过程中有效（run-time）；</li>
<li>执行者将具有该程序拥有者（owner）的权限。</li>
<li>解释：我们的Linux 系统中，所有帐号的密码都记录在/etc/shadow 这个文件里面，这个文件的权限为：“———- 1 root root”，意思是这个文件仅有root可读且仅有root可以强制写入而已，这个文件仅有root 可以修改，那么鸟哥的dmtsai 这个一般帐号使用者能否自行修改自己的密码呢？你可以使用你自己的帐号输入“passwd”这个指令来看看，嘿嘿！一般使用者当然可以修改自己的密码。明明/etc/shadow 就不能让dmtsai 这个一般帐户去存取的，为什么dmtsai 还能够修改这个文件内的密码呢？这就是SUID 的功能啦。也就是1. dmtsai 对于/usr/bin/passwd 这个程序来说是具有x 权限的，表示dmtsai 能执行passwd；2. passwd 的拥有者是root 这个帐号；3. dmtsai 执行passwd 的过程中，会“暂时”获得root 的权限；4. /etc/shadow 就可以被dmtsai 所执行的passwd 所修改。</li>
</ul>
</li>
<li>这样理解p324中的图像，整个特殊权限是赋予给某一个指令的，有的指令是具有这样的特殊权限而有的没有。例如passwd是一个修改密码的指令，它具有特殊权限可以去修改shadow中保存的内容。但是cat就是一个普通的查看指令，他并没有这样的特权，且没有对该shadow文件的普通的读写权限，所以不可读该文件。</li>
<li>另外，SUID 仅可用在binary program 上，不能够用在shell script 上面！这是因为shell script 只是将很多的binary 可执行文件叫进来执行而已！所以SUID 的权限部分，还是得要看shell script 调用进来的程序的设置，而不是shell script 本身。当然，SUID 对于目录也是无效的～这点要特别留意。</li>
<li><p>当s 标志在文件拥有者的x 项目为SUID，那s在群组的x 时则称为Set GID。-rwx–s–x。与SUID 不同的是，SGID 可以针对文件或目录来设置！如果是对文件来说，SGID 有如下的功能：</p>
<ul>
<li>SGID 对二进制程序有用；</li>
<li>程序执行者对于该程序来说，需具备x 的权限；</li>
<li>执行者在执行的过程中将会获得该程序群组的支持！</li>
<li><p>举例来说：上面的/usr/bin/locate 这个程序可以去搜寻/var/lib/mlocate/mlocate.db 这个文件的内容（详细说明会在下节讲述），mlocate.db 的权限如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# ll /usr/bin/locate /var/lib/mlocate/mlocate.db</span><br><span class="line">-rwx--s--x. 1 root slocate 40496 Jun 10 2014 /usr/bin/locate</span><br><span class="line">-rw-r-----. 1 root slocate 2349055 Jun 15 03:44 /var/lib/mlocate/mlocate.db</span><br></pre></td></tr></table></figure>
</li>
<li><p>与SUID 非常的类似，若我使用dmtsai 这个帐号去执行locate 时，那dmtsai 将会取得slocate 群组的支持，因此就能够去读取mlocate.db 啦。感觉就是让一个指令获取了同另一个文件要求的群组的权限相同的权限。</p>
</li>
<li>除了binary program 之外，事实上SGID 也能够用在目录上，这也是非常常见的一种用途！当一个目录设置了SGID 的权限后，他将具有如下的功能：<ul>
<li>使用者若对于此目录具有r 与x 的权限时，该使用者能够进入此目录；</li>
<li>使用者在此目录下的有效群组（effective group）将会变成该目录的群组；</li>
<li>用途：若使用者在此目录下具有w 的权限（可以新建文件），则使用者所创建的新文件，该新文件的群组与此目录的群组相同。</li>
</ul>
</li>
</ul>
</li>
<li>这个Sticky Bit, SBIT 目前只针对目录有效，对于文件已经没有效果了。SBIT 对于目录的作用是：<ul>
<li>当使用者对于此目录具有w, x 权限，亦即具有写入的权限时；</li>
<li>当使用者在该目录下创建文件或目录时，仅有自己与root 才有权力删除该文件;</li>
</ul>
</li>
<li>换句话说：当甲这个使用者于A 目录是具有群组或其他人的身份，并且拥有该目录w 的权限，这表示“甲使用者对该目录内任何人创建的目录或文件均可进行”删除/更名/搬移” 等动作。” 不过，如果将A 目录加上了SBIT 的权限项目时，则甲只能够针对自己创建的文件或目录进行删除/更名/移动等动作，而无法删除他人的文件。</li>
<li>SUID/SGID/SBIT 权限设置：4 为SUID，2 为SGID，1 为SBIT。假设要将一个文件权限改为“-rwsr-xr-x”时，由于s 在使用者权限中，所以是SUID ，因此，在原先的755 之前还要加上4 ，也就是：“ chmod 4755 filename ”来设置。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# cd /tmp</span><br><span class="line">[root@study tmp]# touch test &amp;lt;==创建一个测试用空档</span><br><span class="line">[root@study tmp]# chmod 4755 test; ls -l test &amp;lt;==加入具有SUID 的权限</span><br><span class="line">-rwsr-xr-x 1 root root 0 Jun 16 02:53 test</span><br><span class="line">[root@study tmp]# chmod 6755 test; ls -l test &amp;lt;==加入具有SUID/SGID 的权限</span><br><span class="line">-rwsr-sr-x 1 root root 0 Jun 16 02:53 test</span><br><span class="line">[root@study tmp]# chmod 1755 test; ls -l test &amp;lt;==加入SBIT 的功能！</span><br><span class="line">-rwxr-xr-t 1 root root 0 Jun 16 02:53 test</span><br><span class="line">[root@study tmp]# chmod 7666 test; ls -l test &amp;lt;==具有空的SUID/SGID 权限</span><br><span class="line">-rwSrwSrwT 1 root root 0 Jun 16 02:53 test</span><br><span class="line"></span><br><span class="line">最后一个例子就要特别小心啦！怎么会出现大写的S 与T 呢？不都是小写的吗？因为s 与t都是取代x 这个权限的，但是你有没有发现阿，我们是下达7666 喔！也就是说，user,group 以及others 都没有x 这个可执行的标志（因为666 嘛），所以，这个S, T 代表的就是“空的”啦！怎么说？SUID 是表示“该文件在执行的时候，具有文件拥有者的权限”，但是文件拥有者都无法执行了，哪里来的权限给其他人使用？当然就是空的啦。</span><br></pre></td></tr></table></figure>
<ul>
<li>而除了数字法之外，你也可以通过符号法来处理喔！其中SUID 为u+s ，而SGID 为g+s ，SBIT 则是o+t。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 设置权限成为-rws--x--x 的模样：</span><br><span class="line">[root@study tmp]# chmod u=rwxs,go=x test; ls -l test</span><br><span class="line">-rws--x--x 1 root root 0 Jun 16 02:53 test</span><br><span class="line"># 承上，加上SGID 与SBIT 在上述的文件权限中！</span><br><span class="line">[root@study tmp]# chmod g+s,o+t test; ls -l test</span><br><span class="line">-rws--s--t 1 root root 0 Jun 16 02:53 test</span><br></pre></td></tr></table></figure>
<p>9 观察文件类型：file。如果你想要知道某个文件的基本数据，例如是属于ASCII 或者是data 文件，或者是binary，且其中有没有使用到动态函数库（share library）等等的信息，就可以利用file 这个指令来检阅，如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# file ~/.bashrc</span><br><span class="line">/root/.bashrc: ASCII text &amp;lt;==告诉我们是ASCII 的纯文本文件啊！</span><br><span class="line">[root@study ~]# file /usr/bin/passwd</span><br><span class="line">/usr/bin/passwd: setuid ELF 64-bit LSB shared object, x86-64, version 1 （SYSV）, dynamically</span><br><span class="line">linked （uses shared libs）, for GNU/Linux 2.6.32,</span><br><span class="line">BuildID[sha1]=0xbf35571e607e317bf107b9bcf65199988d0ed5ab, stripped</span><br><span class="line"># 可执行文件的数据可就多的不得了！包括这个文件的suid 权限、相容于Intel x86-64 等级的硬件平台</span><br><span class="line"># 使用的是Linux 核心2.6.32 的动态函数库链接等等。</span><br><span class="line">[root@study ~]# file /var/lib/mlocate/mlocate.db</span><br><span class="line">/var/lib/mlocate/mlocate.db: data &amp;lt;== 这是data 文件！</span><br></pre></td></tr></table></figure>
<h2 id="指令与文件的搜寻"><a href="#指令与文件的搜寻" class="headerlink" title="指令与文件的搜寻"></a>指令与文件的搜寻</h2><p>1 我们常常需要知道那个文件放在哪里</p>
<p>2 指令文件名的搜寻 </p>
<ul>
<li>which （寻找“可执行文件”）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# which [-a] command</span><br><span class="line">选项或参数：</span><br><span class="line">-a ：将所有由PATH 目录中可以找到的指令均列出，而不止第一个被找到的指令名称</span><br><span class="line">范例一：搜寻ifconfig 这个指令的完整文件名</span><br><span class="line">[root@study ~]# which ifconfig</span><br><span class="line">/sbin/ifconfig</span><br><span class="line">范例二：用which 去找出which 的文件名为何？</span><br><span class="line">[root@study ~]# which which</span><br><span class="line">alias which=&apos;alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde&apos;</span><br><span class="line">/bin/alias</span><br><span class="line">/usr/bin/which</span><br><span class="line"># 竟然会有两个which ，其中一个是alias 这玩意儿呢！那是啥？</span><br><span class="line"># 那就是所谓的“命令别名”，意思是输入which 会等于后面接的那串指令啦！</span><br><span class="line"># 更多的数据我们会在bash 章节中再来谈的！</span><br><span class="line">范例三：请找出history 这个指令的完整文件名</span><br><span class="line">[root@study ~]# which history</span><br><span class="line">/usr/bin/which: no history in （/usr/local/sbin:/usr/local/bin:/sbin:/bin:</span><br><span class="line">/usr/sbin:/usr/bin:/root/bin）</span><br><span class="line">[root@study ~]# history --help</span><br><span class="line">-bash: history: --: invalid option</span><br><span class="line">history: usage: history [-c] [-d offset] [n] or history -anrw [filename] or history -ps arg</span><br><span class="line"># 瞎密？怎么可能没有history ，我明明就能够用root 执行history 的啊！</span><br></pre></td></tr></table></figure>
<ul>
<li>最后一个范例最有趣，怎么history 这个常用的指令竟然找不到啊！为什么呢？这是因为history 是“bash 内置的指令”啦！但是which 默认是找PATH 内所规范的目录，所以当然一定找不到的啊（有bash 就有history！）！那怎办？没关系！我们可以通过type 这个指令喔！关于type 的用法我们将在第十章的bash 再来谈。</li>
</ul>
<p>3 文件文件名的搜寻：来谈一谈怎么搜寻文件吧！在Linux 下面也有相当优异的搜寻指令呦！通常find 不很常用的！因为速度慢之外，也很操硬盘！一般我们都是先使用whereis 或者是locate 来检查，如果真的找不到了，才以find 来搜寻呦！为什么呢？因为whereis 只找系统中某些特定目录下面的文件而已，locate 则是利用数据库来搜寻文件名，当然两者就相当的快速，并且没有实际的搜寻硬盘内的文件系统状态，比较省时间啦。</p>
<ul>
<li>whereis （由一些特定的目录中寻找文件文件名）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# whereis [-bmsu] 文件或目录名</span><br><span class="line">选项与参数：</span><br><span class="line">-l :可以列出whereis 会去查询的几个主要目录而已</span><br><span class="line">-b :只找binary 格式的文件</span><br><span class="line">-m :只找在说明文档manual 路径下的文件</span><br><span class="line">-s :只找source 来源文件</span><br><span class="line">-u :搜寻不在上述三个项目当中的其他特殊文件</span><br><span class="line">范例一：请找出ifconfig 这个文件名</span><br><span class="line">[root@study ~]# whereis ifconfig</span><br><span class="line">ifconfig: /sbin/ifconfig /usr/share/man/man8/ifconfig.8.gz</span><br><span class="line">范例二：只找出跟passwd 有关的“说明文档”文件名（man page）</span><br><span class="line">[root@study ~]# whereis passwd # 全部的文件名通通列出来！</span><br><span class="line">passwd: /usr/bin/passwd /etc/passwd /usr/share/man/man1/passwd.1.gz /usr/share/man/man5/passwd.5.gz</span><br><span class="line">[root@study ~]# whereis -m passwd # 只有在man 里面的文件名才抓出来！</span><br><span class="line">passwd: /usr/share/man/man1/passwd.1.gz /usr/share/man/man5/passwd.5.gz</span><br><span class="line"></span><br><span class="line">如果不加任何选项的话，那么就将所有的数据列出来</span><br></pre></td></tr></table></figure>
<ul>
<li>locate / updatedb：locate 的使用更简单，直接在后面输入“文件的部分名称”后，就能够得到结</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# locate [-ir] keyword</span><br><span class="line">选项与参数：</span><br><span class="line">-i ：忽略大小写的差异；</span><br><span class="line">-c ：不输出文件名，仅计算找到的文件数量</span><br><span class="line">-l ：仅输出几行的意思，例如输出五行则是-l 5</span><br><span class="line">-S ：输出locate 所使用的数据库文件的相关信息，包括该数据库纪录的文件/目录数量等</span><br><span class="line">-r ：后面可接正则表达式的显示方式</span><br><span class="line">范例一：找出系统中所有与passwd 相关的文件名，且只列出5 个</span><br><span class="line">[root@study ~]# locate -l 5 passwd</span><br><span class="line">/etc/passwd</span><br><span class="line">/etc/passwd/</span><br><span class="line">etc/pam.d/passwd</span><br><span class="line">/etc/security/opasswd</span><br><span class="line">/usr/bin/gpasswd</span><br><span class="line">范例二：列出locate 查询所使用的数据库文件之文件名与各数据数量</span><br><span class="line">[root@study ~]# locate -S</span><br><span class="line">Database /var/lib/mlocate/mlocate.db:</span><br><span class="line">8,086 directories # 总纪录目录数</span><br><span class="line">109,605 files # 总纪录文件数</span><br><span class="line">5,190,295 Bytes in file names</span><br><span class="line">2,349,150 Bytes used to store database</span><br><span class="line"></span><br><span class="line">locate 来寻找数据的时候特别的快，这是因为locate 寻找的数据是由“已创建的数据库/var/lib/mlocate/” 里面的数据所搜寻到的，所以不用直接在去硬盘当中存取数据。那么有什么限制呢？就是因为他是经由数据库来搜寻的，而数据库的创建默认是在每天执行一次（每个distribution 都不同，CentOS 7.x 是每天更新数据库一次！），所以当你新创建起来的文件，却还在数据库更新之前搜寻该文件，那么locate 会告诉你“找不到。能否手动更新数据库哪？当然可以啊！更新locate 数据库的方法非常简单，直接输入“updatedb ”就可以了！updatedb 指令会去读取/etc/updatedb.conf 这个配置文件的设置，然后再去硬盘里面进行搜寻文件名的动作，最后就更新整个数据库文件啰！因为updatedb 会去搜寻硬盘，所以当你执行updatedb 时，可能会等待数分钟的时间。</span><br></pre></td></tr></table></figure>
<ul>
<li>find查询操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# find [PATH] [option] [action]</span><br><span class="line">选项与参数：</span><br><span class="line">1\. 与时间有关的选项：共有-atime, -ctime 与-mtime ，以-mtime 说明</span><br><span class="line">-mtime n ：n 为数字，意义为在n 天之前的“一天之内”被更动过内容的文件；</span><br><span class="line">-mtime +n ：列出在n 天之前（不含n 天本身）被更动过内容的文件文件名；</span><br><span class="line">-mtime -n ：列出在n 天之内（含n 天本身）被更动过内容的文件文件名。</span><br><span class="line">-newer file ：file 为一个存在的文件，列出比file 还要新的文件文件名</span><br><span class="line">范例一：将过去系统上面24 小时内有更动过内容（mtime）的文件列出</span><br><span class="line">[root@study ~]# find / -mtime 0</span><br><span class="line"># 那个0 是重点！0 代表目前的时间，所以，从现在开始到24 小时前，</span><br><span class="line"># 有变动过内容的文件都会被列出来！那如果是三天前的24 小时内？</span><br><span class="line"># find / -mtime 3 有变动过的文件都被列出的意思！</span><br><span class="line">范例二：寻找/etc 下面的文件，如果文件日期比/etc/passwd 新就列出</span><br><span class="line">[root@study ~]# find /etc -newer /etc/passwd</span><br><span class="line"># -newer 用在分辨两个文件之间的新旧关系是很有用的！</span><br></pre></td></tr></table></figure>
<ul>
<li>find的其他用法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">选项与参数：</span><br><span class="line">2\. 与使用者或群组名称有关的参数：</span><br><span class="line">-uid n ：n 为数字，这个数字是使用者的帐号ID，亦即UID ，这个UID 是记录在/etc/passwd 里面与帐号名称对应的数字。这方面我们会在第四篇介绍。</span><br><span class="line">-gid n ：n 为数字，这个数字是群组名称的ID，亦即GID，这个GID 记录在/etc/group，相关的介绍我们会第四篇说明～</span><br><span class="line">-user name ：name 为使用者帐号名称喔！例如dmtsai</span><br><span class="line">-group name：name 为群组名称喔，例如users ；</span><br><span class="line">-nouser ：寻找文件的拥有者不存在/etc/passwd 的人！</span><br><span class="line">-nogroup ：寻找文件的拥有群组不存在于/etc/group 的文件！</span><br><span class="line">当你自行安装软件时，很可能该软件的属性当中并没有文件拥有者，这是可能的！在这个时候，就可以使用-nouser 与-nogroup 搜寻。</span><br><span class="line">范例三：搜寻/home 下面属于dmtsai 的文件</span><br><span class="line">[root@study ~]# find /home -user dmtsai</span><br><span class="line"># 这个东西也很有用的～当我们要找出任何一个使用者在系统当中的所有文件时，</span><br><span class="line"># 就可以利用这个指令将属于某个使用者的所有文件都找出来喔！</span><br><span class="line">范例四：搜寻系统中不属于任何人的文件</span><br><span class="line">[root@study ~]# find / -nouser</span><br><span class="line"># 通过这个指令，可以轻易的就找出那些不太正常的文件。如果有找到不属于系统任何人的文件时，</span><br><span class="line"># 不要太紧张，那有时候是正常的～尤其是你曾经以源代码自行编译软件时。</span><br></pre></td></tr></table></figure>
<ul>
<li>find的其他用法2</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">选项与参数：</span><br><span class="line">3\. 与文件权限及名称有关的参数：</span><br><span class="line">-name filename：搜寻文件名称为filename 的文件；</span><br><span class="line">-size [+-]SIZE：搜寻比SIZE 还要大（+）或小（-）的文件。这个SIZE 的规格有：c: 代表Byte，k: 代表1024Bytes。所以，要找比50KB还要大的文件，就是“ -size +50k ”</span><br><span class="line">-type TYPE ：搜寻文件的类型为TYPE 的，类型主要有：一般正规文件（f）, 设备文件（b, c）,目录（d）, 链接文件（l）, socket （s）, 及FIFO （p）等属性。</span><br><span class="line">-perm mode ：搜寻文件权限“刚好等于” mode 的文件，这个mode 为类似chmod的属性值，举例来说，-rwsr-xr-x 的属性为4755 ！-perm -mode ：搜寻文件权限“必须要全部囊括mode 的权限”的文件，举例来说，我们要搜寻-rwxr--r-- ，亦即0744 的文件，使用-perm -0744，当一个文件的权限为-rwsr-xr-x ，亦即4755 时，也会被列出来，因为-rwsr-xr-x 的属性已经囊括了-rwxr--r-- 的属性了。</span><br><span class="line">-perm /mode ：搜寻文件权限“包含任一mode 的权限”的文件，举例来说，我们搜寻-rwxr-xr-x ，亦即-perm /755 时，但一个文件属性为-rw-------也会被列出来，因为他有-rw.... 的属性存在！</span><br><span class="line"></span><br><span class="line">范例五：找出文件名为passwd 这个文件</span><br><span class="line">[root@study ~]# find / -name passwd</span><br><span class="line">范例五-1：找出文件名包含了passwd 这个关键字的文件</span><br><span class="line">[root@study ~]# find / -name &quot;*passwd*&quot;</span><br><span class="line"># 利用这个-name 可以搜寻文件名啊！默认是完整文件名，如果想要找关键字，</span><br><span class="line"># 可以使用类似* 的任意字符来处理</span><br><span class="line">范例六：找出/run 目录下，文件类型为Socket 的文件名有哪些？</span><br><span class="line">[root@study ~]# find /run -type s</span><br><span class="line"># 这个-type 的属性也很有帮助喔！尤其是要找出那些怪异的文件，</span><br><span class="line"># 例如socket 与FIFO 文件，可以用find /run -type p 或-type s 来找！</span><br><span class="line">范例七：搜寻文件当中含有SGID 或SUID 或SBIT 的属性</span><br><span class="line">[root@study ~]# find / -perm /7000</span><br><span class="line"># 所谓的7000 就是---s--s--t ，那么只要含有s 或t 的就列出，所以当然要使用/7000，</span><br><span class="line"># 使用-7000 表示要同时含有---s--s--t 的所有三个权限。而只需要任意一个，就是/7000 ～瞭乎？</span><br><span class="line"></span><br><span class="line">假设我想要找出来/usr/bin, /usr/sbin 这两个目录下，只要具有SUID 或SGID 就列出来该文件，你可以这样做</span><br><span class="line">[root@study ~]# find /usr/bin /usr/sbin -perm /6000</span><br></pre></td></tr></table></figure>
<ul>
<li>find的其他用法3</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">选项与参数：</span><br><span class="line">4\. 额外可进行的动作：</span><br><span class="line">-exec command ：command 为其他指令，-exec 后面可再接额外的指令来处理搜寻到的结果。</span><br><span class="line">-print ：将结果打印到屏幕上，这个动作是默认动作！</span><br><span class="line">范例八：将上个范例找到的文件使用ls -l 列出来～</span><br><span class="line">[root@study ~]# find /usr/bin /usr/sbin -perm /7000 -exec ls -l &#123;&#125; \;</span><br><span class="line"># 注意到，那个-exec 后面的ls -l 就是额外的指令，指令不支持命令别名，</span><br><span class="line"># 所以仅能使用ls -l 不可以使用ll 喔！注意注意！</span><br><span class="line">范例九：找出系统中，大于1MB 的文件</span><br><span class="line">[root@study ~]# find / -size +1M</span><br></pre></td></tr></table></figure>
<ul>
<li>find 的特殊功能就是能够进行额外的动作（action）,范例八中特殊的地方有{} 以及\; 还有-exec 这个关键字，这些东西的意义为：<ul>
<li>{} 代表的是“由find 找到的内容”，如上图所示，find 的结果会被放置到{} 位置中；</li>
<li>-exec 一直到\; 是关键字，代表find 额外动作的开始（-exec）到结束（\;），在这中间的就是find 指令内的额外动作。在本例中就是“ ls -l {} ”啰！</li>
<li>因为“ ; ”在bash 环境下是有特殊意义的，因此利用反斜线来跳脱。</li>
</ul>
</li>
</ul>
<p>【本章完结】</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-04-08</span><i class="fa fa-tag"></i><a class="tag" href="/categories/Linux/" title="Linux">Linux </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://yoursite.com/2018/04/08/Chapter6_Linux文件与目录管理/,Hailu's Blog,《鸟哥的Linux私房菜基础篇》Chapter6读书笔记,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2018/04/12/LeetCode53_Maximum Subarray/" title="LeetCode 53. Maximum Subarray">Post Anterior</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2018/04/06/Chapter5_Linux 的文件权限与目录配置/" title="《鸟哥的Linux私房菜基础篇》Chapter5读书笔记">Próximo post</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>