<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Hailu"><title>《C++ Primer 5》Chapter15读书笔记 · Hailu's Blog</title><meta name="description" content="一.OOP概述1 面向对象程序设计(object-oriented-programming)，核心时是数据抽象，继承，动态绑定。
2 基类希望他的派生类各自定义合适的版本，此时基类就将这些函数声明为虚函数。
3 派生类必须在其内部对所有重新定义的虚函数进行声明，可以加上virtual关键字，也可以加"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Hailu's Blog</a></h3><div class="description"><p>53696C656E636520697320676F6C64</p></div></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">Home</a></li><li><a href="/archives">Arquivo</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>《C++ Primer 5》Chapter15读书笔记</a></h3></div><div class="post-content"><h1 id="一-OOP概述"><a href="#一-OOP概述" class="headerlink" title="一.OOP概述"></a>一.OOP概述</h1><p>1 面向对象程序设计(object-oriented-programming)，核心时是数据抽象，继承，动态绑定。</p>
<p>2 基类希望他的派生类各自定义合适的版本，此时基类就将这些函数声明为虚函数。</p>
<p>3 派生类必须在其内部对所有重新定义的虚函数进行声明，可以加上virtual关键字，也可以加。C++11中，允许派生类显示地注明它将使用哪个成员函数改写基类的虚函数。具体措施是在该函数的形参列表之后增加override关键字。</p>
<h1 id="二-定义基类与派生类"><a href="#二-定义基类与派生类" class="headerlink" title="二.定义基类与派生类"></a>二.定义基类与派生类</h1><p>1 继承关系中根节点的类通常都会定义一个虚析构函数。</p>
<p>2 任何构造函数之外的非静态函数都可以是虚函数。关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把一个函数声明为虚函数，则该函数在派生类中隐式地也是虚函数。</p>
<p>3 非虚函数的解析过程在编译时而非运行时。</p>
<p>4 派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权限访问从基类继承而来的成员。派生类可以访问基类中定义的公有成员，但不能访问私有成员。有这样的一种情况是我们希望一些成员是派生类可以访问的，但是其他用户是不可访问的，我们为这样的成员声明其为protected的来达到目的。</p>
<p>5 使用访问说明符来说明派生类是如何从基类派生来的（它控制基类成员是否对派生可见），如果一个派生是公有的：</p>
<ul>
<li>则基类的公有成员也是派生类接口的组成部分</li>
<li>可以将公有派生类型的对象绑定到基类的引用或指针上。</li>
</ul>
<p>6 派生类经常（但不总是）覆盖它继承的虚函数，如果：</p>
<ul>
<li>派生类没有覆盖，派生类直接继承基类的虚函数的版本。</li>
<li>派生类覆盖了，派生类拥有自己定义的该函数的版本。</li>
</ul>
<p>7 派生类对象以及派生类向基类的类型转换：派生类对象含有与基类对应的组成部分，所以，我们可以：</p>
<ul>
<li>把派生类的对象当作基类对象来使用</li>
<li>将基类的指针或引用绑定到派生类对象中的基类部分</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Quote item; <span class="comment">//基类</span></span><br><span class="line">Bulk_quote bulk; <span class="comment">//派生类</span></span><br><span class="line">Quote *p = &amp;item; <span class="comment">//基类指针指向基类对象</span></span><br><span class="line">p = &amp;bulk; <span class="comment">//基类引用绑定在派生类的基类部分</span></span><br><span class="line">Quote &amp;r = bulk; <span class="comment">//基类指针指向派生类的基类部分</span></span><br></pre></td></tr></table></figure>
<p>8 这种转换称为派生类到基类的类型转换。编译器隐式执行这种转换。意味着可以：</p>
<ul>
<li>可以把派生类对象或派生类对象的引用用在需要基类引用的地方。</li>
<li>可以把派生类对象的指针用在需要基类指针的地方。</li>
</ul>
<p>9 派生类构造函数，尽管在派生类中含有从基类继承的成员，但是派生类不能直接初始化这些成员。派生类必须使用基类的构造函数来初始它的基类部分。派生类构造函数同样是通过构造函数初始化列表来将实参传递给基类的构造函数的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; book, <span class="keyword">double</span> p,<span class="built_in">std</span>::<span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc) :</span><br><span class="line">Quote(book, p), min_qty(qty), discount(disc) &#123; &#125;;</span><br><span class="line"><span class="comment">// as before</span></span><br></pre></td></tr></table></figure>
<p>10 继承与静态成员：如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义，不论从基类中派生出来多少个派生类，对于每个静态成员来说仅存在唯一的实例。</p>
<p>11 派生类的声明与其他类差别不大，声明中只能包含类名但是不包含它的派生列表（派生列表应该出现在定义的地方）。</p>
<p>12 被用作基类的类必须已经被定义过了而非仅仅声明了一下。隐含的，一个类不能派生它自己。</p>
<p>13 一个类可以是基类，也可以是派生类：每个类都会继承直接基类的所有成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span> <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span>:</span> <span class="keyword">public</span> Base &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span>:</span> <span class="keyword">public</span> D1 &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>14 防止继承的发生：有时候会有这样的类，我们不希望别人来继承它。C++11中提供了一种防止继承发生的方法,即在类名后面加一个关键字final。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoDerived</span> <span class="title">final</span> &#123;</span> <span class="comment">/* */</span> &#125;; <span class="comment">// NoDerived can't be a base class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span> <span class="comment">/* */</span> &#125;;</span><br><span class="line"><span class="comment">// Last is final; we cannot inherit from Last</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Last</span> <span class="title">final</span> :</span> Base &#123; <span class="comment">/* */</span> &#125;; <span class="comment">// Last can't be a base class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bad</span> :</span> NoDerived &#123; <span class="comment">/* */</span> &#125;; <span class="comment">// error: NoDerived is final</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bad2</span> :</span> Last &#123; <span class="comment">/* */</span> &#125;; <span class="comment">// error: Last is final</span></span><br></pre></td></tr></table></figure>
<p>15 类型转换与继承</p>
<p>16 通常情况下，想把一个引用或者指针绑定到一个对象上，需要引用或指针的类型与对象类型一致，或者，引用与指针是该类型const的引用或指针。存在继承关系的类是一个例外，我们可以将基类指针或引用绑定到派生类对象上。<strong>与内置指针一样，智能指针类也支持派生类向基类的类型转换。这意味着可以将一个派生类对象的指针存储在一个基类的智能指针内。</strong></p>
<p>17 静态类型与动态类型：表达式静态类型在编译时已经知道；动态类型则是运行时才可知的。</p>
<p>18 不存在从基类向派生类的隐式类型转换，即使一个基类指针或引用绑定在一个派生类对象上，我们也不能执行从基类向派生类的转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote bulk;</span><br><span class="line">Quote *itemP = &amp;bulk; <span class="comment">// ok: dynamic type is Bulk_quote</span></span><br><span class="line">Bulk_quote *bulkP = itemP; <span class="comment">// error: can't convert base to derived</span></span><br></pre></td></tr></table></figure>
<p>19 在对象之间不存在类型转换：派生类向基类的自动类型转换只针对指针或者引用类型有效。在派生类类型与基类类型之间不存在这样的转换。然而，有时候我们确实希望有这样的类型转换操作。当给基类构造函数传递一个派生类对象时，实际运行的是基类定义的构造函数，类似的，赋值运算符也是这样的。所以我们可以考虑用这样的做法来“实现”转换的需求：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote bulk; <span class="comment">//派生类对象</span></span><br><span class="line"><span class="function">Quote <span class="title">item</span><span class="params">(bulk)</span></span>; <span class="comment">//使用基类拷贝构造函数</span></span><br><span class="line">item = bulk; <span class="comment">//使用基类拷贝赋值运算符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//多余的部分被直接切掉了</span></span><br></pre></td></tr></table></figure>
<p>20 <strong>派生类向基类的类型转换也可能因为访问受限而变得不可行，后面介绍这一部分。</strong></p>
<h1 id="三-虚函数"><a href="#三-虚函数" class="headerlink" title="三.虚函数"></a>三.虚函数</h1><p>1 使用基类的引用或指针调用一个<strong>虚成员函数</strong>时会执行动态绑定。<strong>所有虚函数必须必须有定义</strong>。对虚函数的调用可能在运行时才被解析（因为运行的时候才能根据动态类型调用相应的）。</p>
<p>2 我们把具有继承关系的多个类型称为多态类型。</p>
<p>3 派生类中的虚函数：派生类覆盖了某个继承而来的虚函数，则他的形参类型必须与被他覆盖的基类函数完全一致。同理，派生类中虚函数的返回类型也必须与基类函数匹配。但是，有一个例外：<strong>当类的虚函数返回类型是类本身的指针或者引用的时候，上述规则无效</strong>。也就是说，如果D由B派生而来，则基类的虚函数可以返回B<em>(或B&amp;)而派生类对应函数可以返回D</em>(或D&amp;)，<strong>只不过这样的返回类型要求从D(派生类)到B(基类)的类型转换是可以访问的</strong>。</p>
<p>4 final与override说明符：如果派生类定义了一个函数与基类函数名字一样，但是参数不一样，编译器认为这是合法行为。（认为是新的，独立的，与虚函数无关的），但实际情况中这一般是错的，因为我们的想法一般是想定义覆盖基类虚函数的函数。以前发现这种错误非常困难，C++11中提供override关键字来说明派生类中的虚函数。这样编译器可以替我们进行检查。<strong>如果我们使用override标记了某个函数，但是这个并没有覆盖已经存在的虚函数，编译器将报错</strong>。</p>
<p>5 我们还可以把某个函数指定为final，如果我们已经把函数定义为final了，则之后任何尝试覆盖函数的操作都将引发错误。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D2</span> :</span> B &#123;</span><br><span class="line">    <span class="comment">// inherits f2() and f3() from B and overrides f1(int)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> final</span>; <span class="comment">// subsequent classes can't override f1(int)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D3</span> :</span> D2 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>; <span class="comment">// ok: overrides f2 inherited from the indirect base B</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span></span>; <span class="comment">// error: D2 declared f2 as final</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>6 final与override关键字出现在形参列表（包含const或引用修饰符）以及尾置返回类型之后。</p>
<p>7 虚函数与默认实参：虚函数可以拥有默认实参，如果某次调用使用了默认实参，<strong>该实参值由本次调用的静态类型决定</strong>。<font color="#FF4500" size="4">换句话说，如果我们通过基类的引用或者指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本。此时，传入派生类函数的将会是基类函数定义的默认实参</font>。<font color="#000080" size="4">如果派生类函数依赖不同的默认实参，程序结果将会与预期不符，所以他俩的默认实参最好一致。</font></p>
<p>8 <strong>回避虚函数的机制：某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本，使用域作用符可以实现这一点。</strong>如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//强行调用基类中定义的函数版本而不管baseP的动态类型是什么，这个调用的解析工作是在编译时完成的</span></span><br><span class="line"><span class="keyword">double</span> undiscounted = baseP-&gt;Quote::net_price(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<h1 id="四-抽象基类"><a href="#四-抽象基类" class="headerlink" title="四.抽象基类"></a>四.抽象基类</h1><p>1 一个纯虚函数无须定义，通过在函数体的位置（在声明语句的分号之前）书写=0就可以将一个虚函数说明为纯虚函数。其中，=0只能出现在类内部的虚函数声明语句处。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Disc_quote</span> :</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Disc_quote() = <span class="keyword">default</span>;</span><br><span class="line">    Disc_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; book, <span class="keyword">double</span> price,<span class="built_in">std</span>::<span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc):Quote(book, price),quantity(qty), discount(disc) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;    <span class="comment">//纯虚函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> quantity = <span class="number">0</span>;   <span class="comment">//折扣适用的购买数量</span></span><br><span class="line">    <span class="keyword">double</span> discount = <span class="number">0.0</span>;      <span class="comment">//折扣的大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2 我们可以为含有纯虚函数的提供构造函数，如上述的Disc_quote定义了两个构造函数，<strong>尽管我们不能直接定义这个类的对象，但是Disc_quote的派生类的构造函数将会使用Disc_quote的构造函数来构建各个派生类对象的Disc_quote部分</strong>。</p>
<p>3 我们也可以为纯虚函数提供定义，但是函数体必须定义在类的外部，也就是说，我们不能在类的内部为一个=0的函数提供函数体。</p>
<p>4 含有纯虚的类是抽象基类：含有（或着未经覆盖直接继承）纯虚函数的类是抽象基类。<strong>抽象基类负责定义接口，后续的其他类可以覆盖接口。我们不能（直接）创建一个抽象基类的对象。</strong></p>
<p>5 派生类构造函数<strong>仅</strong>初始化他的直接基类：</p>
<p>6 重构：重构负责重新设计类的体系以便将操作和/或数据从一个类移动到另一个类中。比如上述中在Quote的继承体系中增加了Disc_quote类是重构的一个典型示例。</p>
<h1 id="五-访问控制与继承"><a href="#五-访问控制与继承" class="headerlink" title="五.访问控制与继承"></a>五.访问控制与继承</h1><p>1 每个类分别控制着其成员对于派生类是否可以访问。</p>
<p>2 受保护的成员protected声明：</p>
<ul>
<li>对于类的用户是不可访问的</li>
<li>对于派生类与友元是可访问的</li>
<li><strong>派生类的成员或友元只能通过派生类对象访问基类的受保护的成员。派生类对于一个基类对象中受保护成员没有任何访问特权</strong>。也就是说我们说的这种可访问性都是针对自己，而非别人。这种可访问性描述的是我继承来的（已经归属于我）东西的访问权限的描述。这与我们的祖先毫无关系，也就是说，我们无权去访问祖先的私有或者受保护的内容。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> prot_mem;                   <span class="comment">//受保护的成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sneaky</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp;)</span></span>;   <span class="comment">//可以访问Sneaky::prot_mem</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base&amp;)</span></span>;     <span class="comment">//不可以访问Base::prot_mem</span></span><br><span class="line">    <span class="keyword">int</span> j;                          <span class="comment">//默认private的</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//正确：clobber能访问Sneaky对象的private和protected成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp;s)</span> </span>&#123; s.j = s.prot_mem = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="comment">//错误：clobber不能访问Base对象的private和protected成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base &amp;b)</span> </span>&#123; b.prot_mem = <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>3 举一个简单的例子说明上述情况，我们从父类那里继承了一条DNA（拷贝过来的），父类在其DNA上有过标记，私有的A，受保护的B，公开的C。我们也将这些权限说明都继承了过来。这时，我们可以访问我们自己身体里的那条拷贝的DNA的数据段B与C，但是我们不能访问A（父类规定了，这是重要信息，不能乱翻，尽管这条DNA属于我们。）。而对父类的那条DNA，在没有其他特殊说明的情况下，我们就是和普通的类一样，没有任何特权（我们不能访问父类DNA的B与A）。</p>
<p>4 上述阐述也就是书中“派生类的成员和友元只能访问派生类对象中的基类部分的受保护成员；对于普通的基类对象中的成员不具有特特殊的访问权限”。</p>
<p>5 公有，私有和受保护继承：每个类对其继承而来的成员的访问权限受到两个因素影响：</p>
<ul>
<li>基类中该成员的访问说明符</li>
<li>派生类的派生列表中的访问说明符</li>
</ul>
<p>6 <font color="#FF4500" size="4">重要概念：派生类访问说明符的目的控制派生类用户（构造的对象以及派生类的派生类）对于基类成员的访问权限，而对于派生类的成员或者友元（函数）能否访问其直接基类的成员没有影响。</font></p>
<p>7 <font color="#2874A6" size="4">解释：这里是一个分工，各司其职的问题，基类的访问说明符管理的是派生类的成员（成员函数，友元函数，数据成员）的权限；而派生访问说明符管理的则是派生类的用户（派生类的某一个对象实例，以及派生类的派生类）的权限。</font></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pub_mem</span><span class="params">()</span></span>; <span class="comment">// public member</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> prot_mem; <span class="comment">// protected member</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> priv_mem; <span class="comment">// private member</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pub_Derv</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> prot_mem; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> priv_mem; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Priv_Derv</span> :</span> <span class="keyword">private</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> prot_mem; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//是基类中的权限说明符在影响成员权限而不是派生说明符</span></span><br><span class="line">------------------------------------------------</span><br><span class="line">Pub_Derv d1; <span class="comment">//public继承</span></span><br><span class="line">Priv_Derv d2; <span class="comment">//private继承</span></span><br><span class="line">d1.pub_mem(); <span class="comment">//正确，可以访问</span></span><br><span class="line">d2.pub_mem(); <span class="comment">//错误，不可访问</span></span><br></pre></td></tr></table></figure>
<p>8 具体是：</p>
<ul>
<li>继承是公有的，成员将遵循原有访问说明符</li>
<li>继承是私有的，成员将都是私有的，不可访问的</li>
<li>继承是受保护的，成员（除了private）都将是受保护的，对象是不能访问受保护的成员，派生类应该可以</li>
</ul>
<table>
<thead>
<tr>
<th>派生方式</th>
<th>基类public成员</th>
<th>基类protected成员</th>
<th>基类private成员</th>
<th>变化</th>
</tr>
</thead>
<tbody>
<tr>
<td>public派生</td>
<td>public</td>
<td>protected</td>
<td>不可见</td>
<td>不变</td>
</tr>
<tr>
<td>private派生</td>
<td>private</td>
<td>private</td>
<td>不可见</td>
<td>变为私有</td>
</tr>
<tr>
<td>protected派生</td>
<td>protected</td>
<td>protected</td>
<td>不可见</td>
<td>变为protected</td>
</tr>
</tbody>
</table>
<p>9 派生访问说明符用于控制继承自派生类的新类的访问权限的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct Derived_from_Public : public Pub_Derv &#123;</span><br><span class="line">//正确: Base::prot_mem在Pub_Derv仍然是protected的</span><br><span class="line">    int use_base() &#123; return prot_mem; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct Derived_from_Private : public Priv_Derv &#123;</span><br><span class="line">//错误：Base::prot_mem在Priv_Derv是private的</span><br><span class="line">    int use_base() &#123; return prot_mem; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>10 派生类向基类的转换是否可访问，一方面个受使用该转换的代码决定，另一方面受派生类的访问说明符影响。假设D继承B：</p>
<ul>
<li>当D公有的继承B时，用户代码才会使用派生类向基类的转换，如果D继承B的方式是受保护的或者私有的，则用户代码不能使用该转换。</li>
<li>无论D是什么方式继承自B，D的成员函数和友元都能访问派生类向基类的转换；派生类向直接基类的类型转换对于派生类的成员和友元来说永远是可访问的。</li>
<li>如果D继承B的方式是公有的或者受保护的，则D的派生类的成员和友元可以使用D向B的类型转换；反之，如果D继承B的方式是私有的，则不能使用。</li>
</ul>
<p>11 友元与继承：友元关系不能传递，也不能继承。但是其可访问性有点大，需要注意：第三个访问中有点奇怪，但是这是可以的。友元可以直接访问类的对象的私有数据，也可以访问<strong>该类的派生类继承于父类的那部分数据成员</strong>。有一种家长强权的感觉。（A是B的好友，A可以询问B的私有数据。B生了一个孩子C后，A是可以访问的C中来自B的私有数据的）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(Base b)</span> </span>&#123; <span class="keyword">return</span> b.prot_mem; &#125;        <span class="comment">//正确，Pal是Base的友元</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">(Sneaky s)</span> </span>&#123; <span class="keyword">return</span> s.j; &#125;            <span class="comment">//错误，Pal不是Base的友元</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f3</span><span class="params">(Sneaky s)</span> </span>&#123; <span class="keyword">return</span> s.prot_mem; &#125;     <span class="comment">//正确，Pal是Base的友元</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>12 改变个别成员的可访问性：有时候我们需要改变派生类继承的某个名字的访问级别，通过using声明可以达到这一目的：我们使用using语句改变了这些成员的可访问性。通过在类的内部使用using语句，我们可以将该类的直接或间接基类中的任何可以访问你的成员标记出来，using声明语句中名字的访问权限由该using声明语句之前的访问说明符决定。也就是说，如果一条using声明语句出现在private部分，则该名字只能被类的成员和友元访问；如果using声明语句出现在public部分，则类的所有用户都能访问它；若出现在protected部分，则该名字对于成员，友元，和派生类是可以访问的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> size() <span class="keyword">const</span> &#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">private</span> Base &#123;          <span class="comment">//注意私有继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::size;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>13 默认的继承保护级别：默认情况下，使用class关键字定义的派生类是私有继承的；而使用struct关键字是公有继承的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span> <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span> :</span> Base &#123; <span class="comment">/* ... */</span> &#125;;     <span class="comment">//默认是public继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> Base &#123; <span class="comment">/* ... */</span> &#125;;      <span class="comment">//默认是private继承</span></span><br></pre></td></tr></table></figure>
<h1 id="六-继承中的类作用域"><a href="#六-继承中的类作用域" class="headerlink" title="六.继承中的类作用域"></a>六.继承中的类作用域</h1><p>1 当存在继承关系时，派生类的作用域嵌套在基类的作用域中。如果一个名字在派生类的作用域内无法解析，则编译器将继续在外层的基类作用域中寻找该名字的定义。</p>
<p>2 在编译的时候进行名字查找：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Disc_quote</span> :</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::pair&lt;<span class="keyword">size_t</span>, <span class="keyword">double</span>&gt; discount_policy() <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;quantity, discount&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// other members as before</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Bulk_quote bulk;</span><br><span class="line">Bulk_quote *bulkP = &amp;bulk; <span class="comment">//静态类型与动态类型一致</span></span><br><span class="line">Quote *itemP = &amp;bulk; <span class="comment">//静态类型与动态类型不一致</span></span><br><span class="line">bulkP-&gt;discount_policy(); <span class="comment">//正确：bulkP的类型是Bulk_quote*</span></span><br><span class="line">itemP-&gt;discount_policy(); <span class="comment">//错误：itemP的类型是Quote*</span></span><br></pre></td></tr></table></figure>
<p>3 名字冲突与继承：和其他作用域一模一样，派生类也能重用定义在直接基类或间接基类中的名字，此时定义在内层作用域中（派生类）的名字将影藏定义在外层作用域（基类）的名字。然后我们也可以使用域运算符来使用影藏的成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    Base(): mem(<span class="number">0</span>) &#123; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> mem;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123;</span><br><span class="line">    Derived(<span class="keyword">int</span> i): mem(i) &#123; &#125;      <span class="comment">// initializes Derived::mem to i</span></span><br><span class="line">                                    <span class="comment">// Base::mem is default initialized</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_mem</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> mem; &#125;   <span class="comment">// returns Derived::mem</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> mem; <span class="comment">// hides mem in the base</span></span><br><span class="line">&#125;;</span><br><span class="line">--------------------------------------</span><br><span class="line"><span class="function">Derived <span class="title">d</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d.get_mem() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// prints 42</span></span><br><span class="line">--------------------------------------</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_base_mem</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Base::mem; &#125;    <span class="comment">//使用被隐藏的成员</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>4 名字查找与继承的过程：</p>
<ul>
<li>确定p的静态类型</li>
<li>p的类中找，找不到则找直接基类中是否有直至顶端。找遍了任然没有则编译器报错</li>
<li>若找到，进行常规类型检查，确认本次调用是否合法</li>
<li>假设合法：<ul>
<li>是虚函数且是通过引用或指针调用的，则将在运行时确定到底运行该虚函数的哪个版本（依据对象动态类型）</li>
<li>不是虚函数或者通过对象调用，将产生一个常规函数调用</li>
</ul>
</li>
</ul>
<p>6 一如既往，名字查找优先于类型检查：如果派生类的成员与基类的某个成员同名，则派生类将在其作用域内影藏该基类成员，即使派生类成员和基类成员的形参列表不一致，基类成员也会被隐藏掉。（一旦名字找到，编译器就不再继续查找，然后检查）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">memfcn</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">memfcn</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">// hides memfcn in the base</span></span><br><span class="line">&#125;;</span><br><span class="line">Derived d; Base b;</span><br><span class="line">b.memfcn(); <span class="comment">// calls Base::memfcn</span></span><br><span class="line">d.memfcn(<span class="number">10</span>); <span class="comment">// calls Derived::memfcn</span></span><br><span class="line">d.memfcn(); <span class="comment">// error: memfcn with no arguments is hidden</span></span><br><span class="line">d.Base::memfcn(); <span class="comment">// ok: calls Base::memfcn</span></span><br></pre></td></tr></table></figure>
<p>7 虚函数是作用域：所以基类与派生类中的虚函数必须拥有相同的形参列表，假如基类与派生类的虚函数接受的实参不同，则无法通过基类引用或指针调用派生类的虚函数。</p>
<p>8 通过基类调用隐藏的虚函数：这个地方还挺让人容易迷糊的，上面那个例子是直接使用对象调用的状况，下面这个例子是使用基类类型的引用或者指针来调用，注意是不太一样的。这个时候，派生类是会<strong>继承</strong>基类的虚函数，而不是覆盖，而不是覆盖，而不是覆盖！！！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">fcn</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//继承D1的Base::fcn()函数</span></span><br><span class="line">    <span class="comment">//又自己新定义了一个fcn(int)函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">// parameter list differs from fcn in Base</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>; <span class="comment">// new virtual function that does not exist in Base</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> <span class="keyword">public</span> D1 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">//非虚函数，隐藏了D1::fcn(int)函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">()</span></span>; <span class="comment">//覆盖了从D1那里继承来的Base的虚函数fcn()</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>; <span class="comment">// overrides virtual f2 from D1</span></span><br><span class="line">&#125;;</span><br><span class="line">---------------------------------------------------------------</span><br><span class="line">Base bobj; D1 d1obj; D2 d2obj;</span><br><span class="line">Base *bp1 = &amp;bobj, *bp2 = &amp;d1obj, *bp3 = &amp;d2obj;</span><br><span class="line">bp1-&gt;fcn(); <span class="comment">//虚调用，运行时调用Base::fcn()</span></span><br><span class="line">bp2-&gt;fcn(); <span class="comment">//虚调用，运行时调用Base::fcn()，因为这个时候D1是继承了Base::fcn()的，其体内是有fcn()的</span></span><br><span class="line">bp3-&gt;fcn(); <span class="comment">//虚调用，普通的虚函数的使用方式，调用了自己体内的D2::fcn()</span></span><br><span class="line">---------------------------------------------------------------</span><br><span class="line">从这个例子还可以看出来一个基类类型的引用或指针是管理了关于他的虚函数</span><br><span class="line">D1 *d1p = &amp;d1obj; D2 *d2p = &amp;d2obj;</span><br><span class="line">bp2-&gt;f2(); <span class="comment">//bp2是Base类指针，它将不管理D1中virtual void f2(),所以这个是错误的调用方式</span></span><br><span class="line">d1p-&gt;f2(); <span class="comment">//d1p是D1类指针，运行时调用D1::f2()</span></span><br><span class="line">d2p-&gt;f2(); <span class="comment">//d1p是D1类指针，运行时调用D2::f2()</span></span><br></pre></td></tr></table></figure>
<p>9 根据上述代码，我们可以得到一个结论，一个基类类型的指针或引用能访问到由基类规范的的虚函数，但是它访问不到派生类新增的用于继承给派生类的派生类的虚函数。也就是说，他只能访问它规定的virtual，尽管都是virtual，但是virtual的归属权是不一样的。</p>
<p>10 再看下面的代码，这里调用的是非虚函数fcn(int),但是因为调用的是非虚函数，所以不会进行动态绑定，实际调用的版本由指针的静态类型决定</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Base *p1 = &amp;d2obj; D1 *p2 = &amp;d2obj; D2 *p3 = &amp;d2obj;</span><br><span class="line">p1-&gt;fcn(<span class="number">42</span>); <span class="comment">// 错误，Base中没有接受一个int的fcn(int)</span></span><br><span class="line">p2-&gt;fcn(<span class="number">42</span>); <span class="comment">// 静态调用D1::fcn(int)</span></span><br><span class="line">p3-&gt;fcn(<span class="number">42</span>); <span class="comment">// 静态调用D2::fcn(int)</span></span><br></pre></td></tr></table></figure>
<p>11 <font color="#FF4500" size="4">这句话很关键“但是因为调用的是非虚函数，所以不会进行动态绑定，实际调用的版本由指针的静态类型决定”。</font>这真是博大精深啊！！！所以得到一个结论：指向派生类的基类指针不能访问派生类的自定义成员。</p>
<p>12 覆盖重载的函数：与其他函数一样，成员函数无论是不是虚函数都能被重载。派生类可以覆盖重载函数的任意个实例。但是，<strong>如果派生类希望所有的重载版本对于他来说都是可见的，那么她就需要覆盖所有的版本，或者一个也不覆盖</strong>。显然这种做法很不简便，因为有时候我们只需要覆盖其中一个。<strong>一种好的解决办法是为重载的成员提供一条using声明语句，这样就无需覆盖基类中每一个重载版本</strong>。using声明语句指定一个名字而不指定形参列表，所以一条基类成员函数的using声明语句就可以把该函数的所有重载版本实例添加到派生类作用域中。然后就可以重载自己指定的版本，这个时候，如果访问了没有重新定义的重载版本，实际上是对using声明点的访问。</p>
<h1 id="七-构造函数与拷贝控制"><a href="#七-构造函数与拷贝控制" class="headerlink" title="七.构造函数与拷贝控制"></a>七.构造函数与拷贝控制</h1><p>1 虚析构函数：基类通常应该定义一个虚析构函数，这样我们就能动态分配继承体系中的对象了。delete一个指针将会执行该对象析构函数，在继承体系中，有可能出现指针静态类型与动态类型不符的情况，所以执行正确的析构函数是一个重要问题。通过在基类中将析构函数定义成虚函数可以确保执行正确的析构函数版本。和其他函数一致，虚函数的虚属性将会被派生类继承，所以继承链上的析构函数都将是虚函数。如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将会产生未定义的行为。</p>
<p>2 基类的析构函数可以不遵循三五法则，就算是有析构函数，也可以没有拷贝构造函数或拷贝赋值运算符。</p>
<p>3 虚析构函数将会阻止合成移动操作：如果一个类定义了析构函数，即使通过=default的形式使用了合成的版本，编译器也不会为这个类合成移动操作。</p>
<p>4 合成拷贝控制与继承：成员可访问，不是被删除的函数就没有什么问题。</p>
<p>5 派生类中删除的拷贝控制与基类额关系：</p>
<ul>
<li>基类的默认构造函数，拷贝构造函数，拷贝赋值运算符是被删除的或是不可访问的，则派生类中对应的成员将是被删除的。</li>
<li>如果基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的。</li>
<li>编译器不会合成一个删除掉的移动操作。如果基类移动操作是删除的或不可访问的，则派生类的=default的合成移动操作将不会被合成。</li>
</ul>
<p>6 移动操作与继承：大多数基类通常有虚析构函数，所以基类通常不含有合成的移动操作，且派生类也不会有合成的移动操作。确实需要时，需要自己定义，应该首先在基类中定义。</p>
<p>7 派生类的拷贝控制成员：派生类其中包含基类部分，所以，派生类的拷贝和移动构造函数在拷贝和移动自由成员的时候，也要拷贝和移动基类的成员。类似，派生类赋值运算符也需为基类部分成员赋值。如果要定义这些操作，就得同时对派生类与基类成员负责。需要显示得调用一下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span> <span class="comment">/* ... */</span> &#125; ;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// by default, the base class default constructor initializes the base part of an object</span></span><br><span class="line">    <span class="comment">// to use the copy or move constructor, we must explicitly call that</span></span><br><span class="line">    <span class="comment">// constructor in the constructor initializer list</span></span><br><span class="line">    D(<span class="keyword">const</span> D&amp; d): Base(d) <span class="comment">// copy the base members //注意这里</span></span><br><span class="line">    <span class="comment">/* initializers for members of D */</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    D(D&amp;&amp; d): Base(<span class="built_in">std</span>::move(d)) <span class="comment">// move the base members //注意这里</span></span><br><span class="line">    <span class="comment">/* initializers for members of D */</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line">D &amp;D::<span class="keyword">operator</span>=(<span class="keyword">const</span> D &amp;rhs)&#123;</span><br><span class="line">    Base::<span class="keyword">operator</span>=(rhs); <span class="comment">// assigns the base part //注意这里</span></span><br><span class="line">    <span class="comment">// assign the members in the derived class, as usual,</span></span><br><span class="line">    <span class="comment">// handling self-assignment and freeing existing resources as appropriate</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>8 派生类析构函数：对象得基类部分时隐式销毁的，所以，派生类析构函数只负责销毁自己分配得资源。，对象销毁顺序与创建顺序相反。</p>
<p>9 继承得构造函数：在C++11中，派生类能够重用其直接定义的构造函数。一个类只能初始化的直接基类，一个类也只继承其直接基类的构造函数。类不能继承默认，拷贝，和移动构造函数。如果派生类没有直接定义这些构造函数，编译器将会为派生类合成它们。派生类继承基类构造函数的方式是提供了一条注明了（直接）基类名的using声明语句：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Disc_quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Disc_quote::Disc_quote; <span class="comment">// inherit Disc_quote's constructors</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>10 通常，using声明语句只是令某个名字在当前作用域内可见，而当用作构造函数时，<strong>using语句将令编译器产生代码，对于基类的每个构造函数，编译器都将生成有一个与之对应的派生类构造函数</strong>。编译器将会在派生类中生成一个形参列表完全相同的构造函数。形如：derived(parms) : base(args) { }，在我们的例子中，继承的构造函数将会等价于：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; book, <span class="keyword">double</span> price,</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc):</span><br><span class="line">Disc_quote(book, price, qty, disc) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果派生类含有自己的数据成员，则这些成员将会被默认初始化。</span></span><br></pre></td></tr></table></figure>
<p>11 继承的构造函数的特点：</p>
<ul>
<li>与普通成员的using声明不一样，一个构造函数的using声明不会改变构造函数的访问级别。</li>
<li>一个using声明语句不能指定explicit或constexpr，如果基类构造函数是explicit或者constexpr的，则继承的构造函数也拥有同样属性</li>
<li>基类构造函数含有默认实参时，这些实参不会被继承。相反，派生类将会获得多个继承的构造函数，每个构造函数分别省略掉一个含有默认实参的形参。</li>
<li>如果基类含有若干构造函数，大多数时候派生类会继承所有的构造函数，有两个例外：<ul>
<li>派生类可以继承一部分构造函数，而为其他构造函数定义自己的版本。如果派生类定义的构造函数与基类的构造函数具有相同的参数列表，则构造函数将不会被继承。定义在派生类的构造函数将替换继承的构造函数。</li>
<li>默认，拷贝，移动构造函数不会被继承，这些构造函数按照正常的规则被合成。</li>
</ul>
</li>
</ul>
<h1 id="八-容器与继承"><a href="#八-容器与继承" class="headerlink" title="八.容器与继承"></a>八.容器与继承</h1><p>1 当我们使用容器存放继承体系中的对象的时候，<strong>通常必须采取间接存储的方式</strong>。因为不允许在容器中保存不同类型的元素，所以不能把具有继承关系的多种类型对象直接存放在容器当中。</p>
<p>2 在容器中放置（智能）指针而非对象，当希望在容器中存放具有继承关系的对象时，我们实际上存放的是基类的指针（更好的选择是智能指针）。我们可以将一个派生类的普通指针转换成基类指针一样，我们也能把一个派生类的智能指针转换成基类的智能指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">shared_ptr</span>&lt;Quote&gt;&gt; basket;</span><br><span class="line">basket.push_back(make_shared&lt;Quote&gt;(<span class="string">"0-201-82470-1"</span>, <span class="number">50</span>));</span><br><span class="line">basket.push_back(</span><br><span class="line">make_shared&lt;Bulk_quote&gt;(<span class="string">"0-201-54848-8"</span>, <span class="number">50</span>, <span class="number">10</span>, <span class="number">.25</span>));</span><br><span class="line"><span class="comment">//动态调用</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; basket.back()-&gt;net_price(<span class="number">15</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>3 make_shared&lt;Bulk_quote&gt;返回一个shared_ptr&lt;Bulk_quote&gt;，当调用push_back()时该对象被转换为shared_ptr<quote>。因此尽管形式上有所差别，但实际上basket的所有元素都是相同的。</quote></p>
<p>4 编写Basket类：略</p>
<h1 id="九-文本查询程序再探"><a href="#九-文本查询程序再探" class="headerlink" title="九.文本查询程序再探"></a>九.文本查询程序再探</h1><p>略</p>
<p>【本章完结】</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-04-15</span><i class="fa fa-tag"></i><a class="tag" href="/categories/C/" title="C++">C++ </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://yoursite.com/2018/04/15/Chapter15_面向对象程序于设计/,Hailu's Blog,《C++ Primer 5》Chapter15读书笔记,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/2018/04/12/LeetCode53_Maximum Subarray/" title="LeetCode 53. Maximum Subarray">Próximo post</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>